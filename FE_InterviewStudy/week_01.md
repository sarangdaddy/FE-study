# Week_01

## 1. Promise 패턴을 활용한 예시를 들어보고 동작원리를 설명해보세요.

> Promise는 비동기 함수 처리 결과로 또 다른 비동기 함수를 처리하는 경우 콜백헬 없이 사용이 가능합니다.  
> 대표적으로 로그인 프로세스를 예로 든다면, 로그인 시도 시 비동기 함수로 ID,PW 일치 여부 요청 후 일치한다는 응답이 오면  
> 그 결과 값으로 다시 비동기 함수를 통해 해당 유저에 대한 정보를 요청 하고, 응답이 오면 이를 화면에 보여주는 로직에 적용이 가능합니다.  
> 위 과정이 가능한 이유는 Promise는 비동기 함수 호출 후 처리되는 과정까지 `상태`를 가지기 때문입니다.  
> Promise는 `pending`, `fulfilled`, `rejected` 중 하나의 상태를 가지며,  
> 초기 상태인 `pending`에서 `fulfilled` 상태로 변경되면 `then`메서드를 통해 결과값을 반환하거나 다른 비동기 함수 호출에 사용됩니다.  
> 만약 `rejected`된다면 `catch` 메서드를 통해 에러를 처리합니다.

## 꼬리 질문 대응 추가 학습

### 1-1. Promise의 then 메서드를 여러 번 연결할 수 있다고 들었습니다. 어떻게 동작하는지 설명해 주실 수 있나요?

> Promise의 then 메서드는 새로운 Promise 객체를 반환합니다.  
> 이를 통해 then 메서드를 연속적으로 연결할 수 있습니다.  
> 첫 번째 then의 반환 값은 두 번째 then의 입력 값으로 사용됩니다.

### 1-2. 앞서 언급한 Promise 패턴 외에 async/await라는 문법도 있는데, 이는 어떻게 동작하고, Promise와 어떤 차이점이 있나요?

> async/await는 Promise를 더 간결하고 동기식 코드처럼 작성할 수 있게 해줍니다.  
> async 함수는 항상 Promise를 반환하며, await는 Promise의 완료 즉, fulfilled를 기다립니다.  
> Promise 패턴을 동기식으로 보여주도록 해주는 것이며 동작 원리는 Promise와 동일합니다.

### 1-3. catch 메서드를 사용하여 에러를 처리한다고 했는데, 여러 then 메서드에 걸쳐 발생하는 모든 에러를 한 번에 처리할 수 있나요?

> 가능합니다. Promise 체인에서 어는 부분에서든 에러가 발생하면, 해당 체인의 가장 가까운 catch 메서드가 호출됩니다.  
> 그래서 일반적으로 체인의 마지막에 catch를 위치 시켜서 모든 에어를 한 곳에서 처리합니다.

### 1-4. Promise 패턴의 다른 활용 사례가 더 있을까요?

> Promise는 API호출, 이미지 로딩, 타이머 등 다양한 비동기 연산에서 활용가능합니다.  
> 예를 들어 이미지 업로드를 요청하는 경우, 이미지를 서버에 업로드하고고 응답을 기다리는 동안  
> 즉, pending 상태 동안 사용자에게 로딩 중임을 보여주는 등 활용이 가능합니다.

### 1-5. Promise.all과 Promise.race라는 메서드도 있던데, 이들의 기능과 사용 방법에 대해 설명해 주실 수 있나요?

> Promise.all은 여러 개의 Promise들이 모두 완료될 때까지 기다린 후 결과를 배열로 반환합니다.  
> Promise.race는 여러 개의 Promise 중 하나라도 완료되면 그 결과를 반환합니다.

</br>

## 2. 이벤트 위임방식의 장점을 무엇인가요?

> 이벤트 위임은 이벤트 버틀링을 이용한 방식으로 상위 요소에게 이벤트를 부여하고 그 하위 요소들에서 이벤트를 사용할 수 있습니다.  
> 이는 불필요한 이벤트 생성을 줄이고, 동적으로 생성/삭제되는 하위 요소 처리가 가능하며  
> 상위 요소의 이벤트만 관리하면 되므로 유지보수성도 향상됩니다.

## 꼬리 질문 대응 추가 학습

### 2-1. 이벤트 위임을 사용할 때 상위 요소를 어떻게 선택하는 것이 최적인가요?

> 이벤트를 처리하고자 하는 하위 요소들의 공통된 부모를 선택해야합니다.  
> 너무 높은 레벨의 요소를 선택하면 원하지 않은 다른 요소로부터의 이벤트로 처리 될 수 있으므로 적절한 부모 요소를 선택해야 합니다.

### 2-2. 이벤트 캡쳐링 (capturing)에 대해서도 아시나요? 이벤트 위임에 캡쳐링을 사용할 경우 어떻게 되나요?

> 이벤트 캡쳐링은 이벤트 버블링의 반대 방향으로, 즉 상위 요소에서 하위 요소로 전파되는 방식입니다.  
> 이벤트 위임에 사용하면 상위 요소에서 이벤트를 먼저 처리할 수 있습니다.  
> 이는 이벤트 버블링을 막기위해 사용되는 `event.stopPropagation()`을 대체할 수 있습니다.

</br>

## 3. prototype을 이용해서 어떻게 상속을 구현할 수 있나요?

> 자바스크립트는 객체 기반의 프로그래밍 언어로 원시 타입의 값을 제외한 모든 값들은 객체입니다.  
> 이 객체는 `[[Prototype]]`이라는 내부 속성을 가지며 이는 다른 객체를 참조할 수 있습니다.  
> **자식 객체의 프로토타입을 부모 객체의 인스턴스로 설정하면 상속이 구현됩니다.**  
> 이렇게 연결된 객체의 체인을 프로토타입 체인이라하며 이를 통해 다른 객체의 속성과 메서드를 사용할 수 있습니다.

## 꼬리 질문 대응 추가 학습

### 3-1. 프로토타입 기반 상속 외에 다른 상속 방법은 없나요?

> ES2015에서 도입된 `class` 문법으로 클래스 기반의 상속 방식이 가능합니다.  
> 다만 `class` 문법도 내부적으로는 프로토타입을 사용하고 있습니다.

</br>

## 4. 자바스크립트 this의 특징을 설명해보세요.

> this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 식별자 입니다.  
> 이 this를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티나 메서드를 참조할 수 있습니다.  
> 중요한 특징으로는 this는 동적으로 결정되는데 "누가 this를 호출했는가?"에 따라 this에 바인딩 되는 값이 결정됩니다.  
> **즉, 함수 객체가 생성되는 시점이 아닌 호출 시점에 결정됩니다.**  
> 때문에 일반 함수로 호출하면 호출한 대상은 전역이 되기에 this는 전역 객체를 가리킵니다.  
> 이러한 문제를 피하기 위해 명시적 바인딩(bind)나 화살표 함수를 사용합니다.

## 꼬리 질문 대응 추가 학습

### 4-1. `call`, `apply`, `bind`의 차이점은 무엇인가요? 언제 사용하나요?

> 셋 모두 함수를 호출하면서 `this`값을 저정합니다.  
> 다만 call은 매개변수를 전달하고, apply는 배열 매개변수를 전달합니다.  
> bind는 새로운 함수를 반환합니다.  
> call, apply는 함수를 즉시 호출할 때 사용하며, bind는 this 값으로 바인딩된 새로운 함수를 나중에 호출하기 위해 사용합니다.

### 4-2. 화살표 함수에서 this가 어떻게 작동하는지 자세히 설명해 주세요.

> this는 호출된 시점에 정해진다고 했지만 화살표 함수에서는 화살표 함수가 정의된 시점에 this가 정해집니다.  
> 이를 렉시컬 바인딩이라고 하며, 화살표 함수가 정의된 시점의 렉시컬 환경의 this 값을 상속 받습니다.  
> **쉽게 말하면 화살표 함수가 정의된 시점의 외부 스코프에서 계승받는다.**

</br>

## 5. 쿠키는 무엇이고 어떻게 활용할 수 있나요?

> 쿠키는 서버가 사용자의 웹 브라우저에 전송하는 작은 데이터 조각입니다.  
> 브라우저는 이 데이터 조각을 저장해 놓았다가, 동일한 서버에 재요청 시 저장된 데이터를 함께 전송합니다.  
> 서버는 쿠키를 통해 두 요청이 동일한 브라우저에서 들어왔는지 아닌지를 판단할 수 있습니다.  
> 이를 통해 stateless인 HTTP 프로토콜에서도 상태 정보를 사용할 수 있게 됩니다.  
> 주로 사용자의 세션 정보나 환경 설정과 같은 데이터를 저장하고 추적하기 위해 사용됩니다.

## 꼬리 질문 대응 추가 학습

### 5-1. 그렇다면 세션은 무엇인가요?

> 서버 측에서 관리되며, 사용자별로 고유한 정보를 저장하는 임시 저장소 입니다.  
> 세션 ID는 쿠키를 통해 클라이언트에 전달됩니다.  
> 쿠키와 세션의 가장 큰 차이점은 쿠키는 클라이언트(브라우저)에 저장되며 세션은 서버에 저장됩니다.

### 5-2. 쿠키의 보안 문제점은 무엇이며, 이를 해결하기 위한 방법은 무엇인가요?

> 쿠키는 클라이언트 사이드에서 접근 가능하므로 중요한 데이터는 저장하면 안됩니다.  
> 중요한 정보는 서버에 저장하고 쿠키에는 해당 정보에 접급할 수 있는 `키`를 저장합니다.

### 5-3. LocalStorage는 다른건가요?

> 로컬 스토리지는 브라우저에서 키-값 쌍으로 데이터를 저장하는 클라이언트 측 저장소입니다.  
> 로컬 스토리지는 웹 스토리지 API의 일부로, 데이터를 브라우저 내에 영구적으로 저장합니다.  
> 반면에 쿠키는 HTTP 요청과 응답 헤더에 포함되어 서버와 클라이언트 간에 데이터를 교환합니다.  
> 이로 인해 쿠키는 모든 HTTP 요청에 자동으로 포함되기 때문에 데이터 전송의 부담이 있을 수 있습니다.  
> 로컬 스토리지는 큰 저장 용량을 제공하며, 쿠키와 달리 만료 날짜가 없습니다.  
> 또한, 로컬 스토리지는 오직 자바스크립트를 통해서만 접근 및 조작이 가능하므로, HTTP 헤더를 통한 데이터 전송이 발생하지 않습니다.
