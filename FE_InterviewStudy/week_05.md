# Week_05

## 1-1. 클로저는 무엇인가요?

- 우선 클로저란 함수 내부에서 선언된 함수 즉 중첩함수를 뜻합니다.
- 모든 중첩함수가 아닌 선언된 시점의 환경을 참조(기억)하는 중첩함수가 클로저 입니다.
- 특정 함수가 내부에서 `변수a`를 선언하고 `함수𝛂`를 선언한다면 이 함수는 호출 후 종료됩니다.
- 일반적이라면 선언된 `변수a`는 특정 함수의 종료와 함께 사라집니다.
- 하지만 내부에서 선언된 `𝛂함수`가 `변수a`를 참조하고 있다면, `변수a`는 클로저라는 스코프에 저장되어 사라지지 않습니다.
- 이 `변수a`를 자유변수라 하며 자유변수를 참조하는 중첩함수 즉, `𝛂함수`가 클로저 입니다.

## 1-2. 커링은 무엇인가요?

- 커링은 함수의 인자를 분할하여 받는 기법입니다.
- 여러개의 인자를 받는 함수가 있다면 **하나의 인자만 받는 여러 함수**로 나누는 기법입니다.
- 분할된 함수들은 하나의 인자를 받고, 다음 인자를 처리할 새로운 함수를 반환합니다.
- 커링은 함수의 재사용성을 높이고, 코드의 명확성을 개선하는 함수형 프로그래밍에서 널리 사용되는 기법입니다.
- 함수를 하나의 인자만 받도록 분할하기에 커링된 함수 단계에서의 상태 유지를 위해 클로저가 사용됩니다.

## 2. method chaining이란?

- method chaining은 OOP에서 사용되는 기법으로, 여러 메소드를 연속적으로 연결하는 방식입니다.
- 이 기법은 코드가 하나의 문장처럼 읽힐 수 있게되어 가독성이 좋습니다.
- 연결된 각각의 메소드는 객체 자신을 반환합니다.
- 즉, 각각의 메소드는 자신(this)를 반환하고 동일한 객체(클래스)내의 메서드로 구성되어야 합니다.
- 체이닝의 종료로 사용되는 메소드는 최종 계산 결과를 반환합니다.
- 코드의 간결성과 유지보수에는 용이하지만 디버깅의 어려움과 성능 문제의 단점을 가지고 있습니다.

## 3-1. promise와 callback의 차이점은?

- 비동기로 동작하는 코드는 결과가 나중에 나옵니다.
- 하지만 비동기로 동작하는 코드를 호출하는 비동기 함수는 호출 후 바로 종료됩니다.
- 즉, 비동기 함수 내부의 비동기로 동작하는 코드는 처리 결과를 외부로 반환하거나 상위 스코프로 할당되지 않습니다.
- 이 문제를 해결하기 위해 내부의 비동기 동작으로 동작하는 코드를 비동기 함수에게 콜백해주는 기법이 나왔습니다.
- 콜백으로 나중에 결과가 나와도 재호출을 통해 결과를 처리할 수 있었지만,
- 그 결과를 다시 비동기 함수로 호출함을 반복한다면 콜백이 계속 추가되어 코드가 콜백 헬이 됩니다.
- 이러한 로직은 코드를 복잡하게 만들어 가독성과 유지 보수성이 좋지 못합니다.
- 이 문제를 해결하기 위해 Promise 패턴이 등장합니다.
- Promise 패턴은 콜백함수를 전달하는 과정으로 동기적으로 표현하게 해줍니다.
- 비동기 로직 결과를 객체로 반환하고 then 메서드를 통해 다음 비동기 함수에 전달할 수 있습니다.
- 또한, callback 패턴에서는 매번 에러처리 코드를 추가해야 했지만,
- Promise에는 catch 메서드를 통해 연결된 비동기 처리의 에러를 한번에 처리할 수 있습니다.
- 그리고 Promise에는 pending, fulfilled, rejected와 같은 상태가 존재하며
- 각각의 상태는 현재의 비동기 처리 상태를 알려줌으로 상태에 따라 로딩 페이지를 보여주는 등
- 비동기 함수의 사용에 있어 사용자 친화적으로 처리가 가능합니다.

## 3-2. Promise vs callback 정리

### Callback

- 기본 개념: Callback은 비동기 작업이 완료된 후 실행되어야 하는 함수입니다. 이 함수는 비동기 작업이 완료된 후 결과(또는 에러)와 함께 호출됩니다.
- 콜백 지옥: 복잡한 비동기 로직을 처리할 때, 여러 콜백 함수가 중첩되는 현상이 발생할 수 있습니다. 이를 '콜백 지옥(Callback Hell)'이라고 부르며, 코드의 가독성과 유지 보수성을 저하시킵니다.
- 에러 처리: 각 콜백 함수마다 에러 처리 로직을 별도로 구현해야 하며, 이는 중복된 코드와 복잡성을 증가시킵니다.

### Promise

- 비동기 처리의 캡슐화: Promise는 비동기 작업을 캡슐화한 객체입니다. 이 객체는 비동기 작업의 완료 또는 실패와 그 결과를 나타냅니다.
- 체인 형태의 처리: .then() 메서드를 사용하여 비동기 작업의 결과를 처리할 수 있으며, 여러 .then()을 연결하여 복잡한 비동기 로직을 보다 선형적으로 표현할 수 있습니다.
- 에러 처리의 단순화: .catch() 메서드를 통해 연결된 모든 비동기 작업의 에러를 한 곳에서 처리할 수 있습니다. 이는 에러 처리 로직을 중앙화하고 코드의 간결성을 높입니다.
- 상태 관리: Promise는 세 가지 상태(pending, fulfilled, rejected)를 가지며, 이를 통해 비동기 작업의 현재 상태를 관리할 수 있습니다.

> Callback은 기본적인 비동기 처리 메커니즘이며, Promise는 이러한 콜백의 복잡성을 해결하고자 등장한 보다 진화된 패턴입니다.  
> Promise는 콜백 지옥을 해결하고, 에러 처리를 단순화하며, 비동기 작업의 상태를 보다 명확하게 관리할 수 있는 장점을 가지고 있습니다.
