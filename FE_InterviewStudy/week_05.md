# Week_05

## 1-1. 클로저는 무엇인가요?

- 우선 클로저란 함수 내부에서 선언된 함수 즉 중첩함수를 뜻합니다.
- 모든 중첩함수가 아닌 선언된 시점의 환경을 참조(기억)하는 중첩함수가 클로저 입니다.
- 특정 함수가 내부에서 `변수a`를 선언하고 `함수𝛂`를 선언한다면 이 함수는 호출 후 종료됩니다.
- 일반적이라면 선언된 `변수a`는 특정 함수의 종료와 함께 사라집니다.
- 하지만 내부에서 선언된 `𝛂함수`가 `변수a`를 참조하고 있다면, `변수a`는 클로저라는 스코프에 저장되어 사라지지 않습니다.
- 이 `변수a`를 자유변수라 하며 자유변수를 참조하는 중첩함수 즉, `𝛂함수`가 클로저 입니다.

## 1-2. 커링은 무엇인가요?

- 커링은 함수의 인자를 분할하여 받는 기법입니다.
- 여러개의 인자를 받는 함수가 있다면 **하나의 인자만 받는 여러 함수**로 나누는 기법입니다.
- 분할된 함수들은 하나의 인자를 받고, 다음 인자를 처리할 새로운 함수를 반환합니다.
- 커링은 함수의 재사용성을 높이고, 코드의 명확성을 개선하는 함수형 프로그래밍에서 널리 사용되는 기법입니다.
- 함수를 하나의 인자만 받도록 분할하기에 커링된 함수 단계에서의 상태 유지를 위해 클로저가 사용됩니다.

## 2. method chaining이란?

- method chaining은 OOP에서 사용되는 기법으로, 여러 메소드를 연속적으로 연결하는 방식입니다.
- 이 기법은 코드가 하나의 문장처럼 읽힐 수 있게되어 가독성이 좋습니다.
- 연결된 각각의 메소드는 객체 자신을 반환합니다.
- 즉, 각각의 메소드는 자신(this)를 반환하고 동일한 객체(클래스)내의 메서드로 구성되어야 합니다.
- 체이닝의 종료로 사용되는 메소드는 최종 계산 결과를 반환합니다.
- 코드의 간결성과 유지보수에는 용이하지만 디버깅의 어려움과 성능 문제의 단점을 가지고 있습니다.

## 3-1. promise와 callback의 차이점은?

- 비동기로 동작하는 코드는 결과가 나중에 나옵니다.
- 하지만 비동기로 동작하는 코드를 호출하는 비동기 함수는 호출 후 바로 종료됩니다.
- 즉, 비동기 함수 내부의 비동기로 동작하는 코드는 처리 결과를 외부로 반환하거나 상위 스코프로 할당되지 않습니다.
- 이 문제를 해결하기 위해 내부의 비동기 동작으로 동작하는 코드를 비동기 함수에게 콜백해주는 기법이 나왔습니다.
- 콜백으로 나중에 결과가 나와도 재호출을 통해 결과를 처리할 수 있었지만,
- 그 결과를 다시 비동기 함수로 호출함을 반복한다면 콜백이 계속 추가되어 코드가 콜백 헬이 됩니다.
- 이러한 로직은 코드를 복잡하게 만들어 가독성과 유지 보수성이 좋지 못합니다.
- 이 문제를 해결하기 위해 Promise 패턴이 등장합니다.
- Promise 패턴은 콜백함수를 전달하는 과정으로 동기적으로 표현하게 해줍니다.
- 비동기 로직 결과를 객체로 반환하고 then 메서드를 통해 다음 비동기 함수에 전달할 수 있습니다.
- 또한, callback 패턴에서는 매번 에러처리 코드를 추가해야 했지만,
- Promise에는 catch 메서드를 통해 연결된 비동기 처리의 에러를 한번에 처리할 수 있습니다.
- 그리고 Promise에는 pending, fulfilled, rejected와 같은 상태가 존재하며
- 각각의 상태는 현재의 비동기 처리 상태를 알려줌으로 상태에 따라 로딩 페이지를 보여주는 등
- 비동기 함수의 사용에 있어 사용자 친화적으로 처리가 가능합니다.

## 3-2. Promise vs callback 정리

### Callback

- 기본 개념: Callback은 비동기 작업이 완료된 후 실행되어야 하는 함수입니다. 이 함수는 비동기 작업이 완료된 후 결과(또는 에러)와 함께 호출됩니다.
- 콜백 지옥: 복잡한 비동기 로직을 처리할 때, 여러 콜백 함수가 중첩되는 현상이 발생할 수 있습니다. 이를 '콜백 지옥(Callback Hell)'이라고 부르며, 코드의 가독성과 유지 보수성을 저하시킵니다.
- 에러 처리: 각 콜백 함수마다 에러 처리 로직을 별도로 구현해야 하며, 이는 중복된 코드와 복잡성을 증가시킵니다.

### Promise

- 비동기 처리의 캡슐화: Promise는 비동기 작업을 캡슐화한 객체입니다. 이 객체는 비동기 작업의 완료 또는 실패와 그 결과를 나타냅니다.
- 체인 형태의 처리: .then() 메서드를 사용하여 비동기 작업의 결과를 처리할 수 있으며, 여러 .then()을 연결하여 복잡한 비동기 로직을 보다 선형적으로 표현할 수 있습니다.
- 에러 처리의 단순화: .catch() 메서드를 통해 연결된 모든 비동기 작업의 에러를 한 곳에서 처리할 수 있습니다. 이는 에러 처리 로직을 중앙화하고 코드의 간결성을 높입니다.
- 상태 관리: Promise는 세 가지 상태(pending, fulfilled, rejected)를 가지며, 이를 통해 비동기 작업의 현재 상태를 관리할 수 있습니다.

> Callback은 기본적인 비동기 처리 메커니즘이며, Promise는 이러한 콜백의 복잡성을 해결하고자 등장한 보다 진화된 패턴입니다.  
> Promise는 콜백 지옥을 해결하고, 에러 처리를 단순화하며, 비동기 작업의 상태를 보다 명확하게 관리할 수 있는 장점을 가지고 있습니다.

## 4. Event Loop는 어디에 존재하는가?

- 이벤트 루프는 브라우저(서버 환경에서는 NodeJS)에 존재합니다.
- 웹 페이지가 화면에 보여지기 위해서는 url을 통해 서버로 부터 리소스(HTML, CSS, JS)를 받아옵니다.
- 리소스를 렌더링 하기위해 브라우저는 `렌더링 엔진`과 `자바스크립트 엔진`을 가지고 있습니다.
- `렌더링 엔진`으로 HTML, CSS를 파싱하여 렌더 트리를 만들고
- `자바스크립트 엔진`으로 JS를 파싱하여 AST를 생성하고 바이트 코드로 변환하여 실행합니다.
- 콜 스택과 힙으로 구성된 `자바스크립트 엔진`은 태스크가 요청되면 콜 스택을 통해 요청된 작업을 순차적으로 실행합니다.
- 여기서 중요한 점은 `자바스크립트 엔진`은 **코드의 평가와 실행만을 담당한다는 것입니다.**
- 즉, 순차적으로 평가된 코드가 실행되도록 하는 역할만 합니다.
- **그렇다면 콜백으로 전달된 비동기 코드는 비동기 처리 후 어떻게 순서를 지정 받고 실행될가요?**
- 이를 위해 브라우저 환경에 내장된 `이벤트 루프`와 `태스크 큐`가 존재합니다.
- `태스크 큐`에는 비동기 함수의 콜백 함수 또는 이벤트 핸들러(setTimeout 등)가 일시적으로 보관되는 영역입니다.
- 추가적으로 프로미스의 후속 처리 메서드(then, catch, finally)를 먼저 처리해주는 `마이크로태스크큐`도 존재합니다.
- `태스크 큐`에 보관된 비동기 함수와 `자바스크립트 엔진`의 `콜스택`을 계속 확인하는게 `이벤트 루프` 입니다.
- `이벤트 루프`는 `자바스크립트 엔진`의 `콜스택`이 비어 있고 태스크 큐에 대기 중인 비동기 함수가 존재한다면
- `태스크 큐`에 대기중인 비동기 함수를 순차적으로 `콜스텍`으로 이동시킵니다. (마이크로태스트큐 우선)
- 콜스텍으로 이동된 비동기 함수는 `자바스크립트 엔진`의 `콜스택`에 들어오게 되면서 실행됩니다.
- 싱글 스레드인 자바스크립트 엔진이 비동기적으로 코드를 실행할 수 있게 해주는 핵심 개념입니다.

## 5. async, await는 무엇인가?

- `async, await`는 비동기 코드 작성 방법인 `Promise 패턴을 동기적`으로 작성할 수 있게 해줍니다.
- 중요한 점은 async, await도 Promise를 기반으로 동작합니다.
- 다만, Promise 후속처리 메서드 (then, catch, finally) 없이 동기 처리 처럼 구현할 수 있게 해주는 겁니다.
- 이는 `ECMAScript 2015`에 도입된 `제너레이터` 기능으로 가능합니다.
- `제너레이터`는 코드 블록의 실행을 일시 중지했다가 필요한 시점에 재개할 수 있는 특수한 함수입니다.
- 가독성이 좋지 않은 제너레이터를 이용한 동기식 Promise 패턴을 `ECMAScript 2017`에 `async, await`로 도입했습니다.
- 함수를 `async`키워드로 정의하면 함수는 언제나 Promise를 반환합니다.
- **이 함수 내부에 `await`키워드를 사용하면 Promise가 `settled(fulfilled or rejected)` 상태가 될 때까지 함수는 일시 중지됩니다.**
- Promise가 `settled` 상태가 된다면 프로미스가 resolve한 처리 결과를 반환합니다.
- 이는 비동기 코드를 동기적으로 작성이 가능하여 가독성이 좋아지며,
- 콜백 패턴이나 Promise패턴에서는 사용이 불가했던 `try...catch문`을 사용하여 에러를 캐치할 수 있습니다.
- 개인적으로는 내부의 await 키워드로 비동기 작업을 순차적으로 실행할 수 있으며,
- 각 작업의 결과를 변수에 저장하고 후속 작업에서 사용할 수 있다는 점이 가독성에 매우 좋았습니다.
- 또한, 비동기 작업의 순서를 컨트롤하기에 매우 유용합니다.
