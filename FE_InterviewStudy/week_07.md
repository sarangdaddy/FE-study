# Week_07

## 1. 가비지 컬렉터의 역할은? 어떻게 작동하는가?

- 가비지 컬렉터는 `메모리 관리`에서 중요 개념입니다.
- 자바스크립트에서 메모리는 `스택`과 `힙`으로 구분됩니다.
- 코드가 실행되면 각 함수의 지역변수가 스택에 저장되는데, 변수의 값이 정적(원시값)인 경우 변수와 함께 값이 스택에 저장되지만,
- 변수의 값이 동적(객체, 배열, 함수) 데이터인 경우에는 그 값을 참조하는 좌표값(참조 타입 변수)만이 스택에 저장됩니다.
- 실제 동적 데이터는 힙에 저장되어 참조 좌표값으로 해당 값을 읽어 오는 개념입니다.
- 이는 변경이 가능한 값인 경우 동일한 메모리 공간을 사용하여 효율성을 높여주기 위한 구조입니다.
- 하지만 이러한 구조에는 문제점이 하나 존재합니다.
- 스택에 쌓인 `정적 데이터`와 `좌표값(참조 타입 변수)`인 경우 실행 후 제거되지만,
- 힙에 저장된 동적 데이터(객체) 값은 실행 후에도 제거되지 않습니다.
- 이를 위해 가비지 컬렉터가 존재합니다.
- 배열과 함수는 모두 객체이기에 동적 데이터를 객체로 표현하겠습니다.
- **즉, 가비지 컬렉터는 더 이상 참조되지 않는 객체를 제거합니다.**
- 작동 원리로는 `참조 카운팅`, `마킹-스위핑`이 존재합니다.
- 참조 카운팅은 객체가 다른 객체에 의해 참조되면 참조 카운터를 증가시킵니다.
- 참조가 제거되면 카운트가 감소하여 0이 되면 가비지 컬렉터에 의해 제거됩니다.
- 다만, 참조 카운팅은 `순환 참조` 즉, 서로가 참조하는 객체의 경우 메모리 회수가 불가하다는 단점이 존재합니다.
- 이에 적용된 방식이 마싱-스위핑 방식입니다.
- 마킹-스위핑은 `루트`로부터 시작하여 접근 가능한 모든 객체를 마킹합니다.
- 여기서 루트는 전역 변수 같은 환경에서 항상 접근 가능한 객체를 의미합니다.
- 마킹 과정에서 도달되지 않는 (접근 불가한) 객체들은 스위핑(청소)과정에서 제거됩니다.
- 이는 순환 참조가 발생해도 접근이 불가하다면 제거되기에 현재 자바스크립트 엔진에서 사용되는 방식입니다.

> 가비지 컬렉터는 사용되지 않는 메모리를 자동으로 해체하는 것.  
> 메모리 누수를 방지하고, 애플리케이션의 성능 및 안정성을 유지해준다.

## 2. 자바 스크립트의 순환 참조란? 어떤게 문제인가? 해결 방법은?

- 순환 참조는 두 개 이상의 객체가 서로를 참조하는 상황입니다.
- 과거에는 가비지 컬렉션이 `참조 카운팅` 방식으로 동작하여
- 서로가 참조를 한다면 메모리에서 해제되지 않아 메모리 누수의 문제가 존재했습니다만,
- 현대의 자바스크립트 엔진은 `마킹-스위핑` 동작으로 이러한 문제를 해결했습니다.
- 하지만, **모듈 시스템에서의 순환 참조**는 로딩 순서와 모듈 초기화에 관련된 문제를 일으킬 수 있습니다.
- 각각의 파일이 객체로 구현되어 export, import 방식으로 서로가 참조하게 구현된 모듈 시스템의 경우
- 두 개 이상의 모듈이 서로를 임포트하는 경우 발생합니다.
- 이러한 경우에는 특정 모듈이 완전히 로드되기 전에 사용될 수 있으며,
- 이는 미완성된 상태의 모듈이 사용되어 `정의되지 않은 상태`가 될 수 있습니다.
- 이를 해결하기 위해 `별도의 모듈 분리`와 `로직 & UI 모듈의 구분`등의 설계 방식을 채택할 수 있습니다.
- [Circular Dependency Plugin](https://www.npmjs.com/package/circular-dependency-plugin)와 같은 순환 참조를 감지해주는 도구를 활용할 수 도 있습니다.

## 3. 자바스크립트의 배열은 실제 자료구조 배열이 아니다. 그 이유는?

- 일반적인 자료구조 배열은 동일한 크기의 메모리 공간이 `빈틈없이 연속적`으로 나열된 자료구조를 말합니다.
- 즉, 배열의 요소는 하나의 데이터 타입으로 `통일`되어 있으며 서로 연속적으로 인접해 있습니다.
- 이러한 일반적인 자료구조 배열을 `밀집 배열`이라 합니다.
- 하지만 자바스크립트 배열은 요소를 위한 메모리 공간의 크기가 동일하지 않아도 되며 연속적으로 이어져 있지 않아도 됩니다.
- 때문에 자바스크립트 배열은 [10, "string", , undefined] 처럼 다른 타입, 빈값을 가질 수 있습니다.
- **이러한 이유는 자바스크립트 배열은 일반적인 배열을 흉내 낸 객체이기 때문입니다.**
- 일반적인 객제가 가지는 `프로퍼티 키`가 `인덱스를 나타내는 문자열`일 뿐이며, `프로퍼티 값`으로 `요소`를 가지고 있습니다.
- 이를 `희소 배열(sparse array)`이라고 합니다.
- 희소 배열은 해시 테이블로 구현되어있기에 일반적인 배열보다 임의 접근이 느리다는 단점을 가지며
- 선형 검색이나 요소의 추가, 삭제의 경우에는 일반적인 배열보다 빠릅니다.
- 자바스크립트 배열이 객체라고는 하지만, 일반 객체와는 구별하여 배열적인 기능으로 최적화 되어있기 때문에
- 객체보다 배열로서의 역할에 효율적이며 `length와` `배열 메서드`를 활용할 수 있다.

## 4. 자바스크립트의 이벤트 루프에 대해 설명해주세요.

- 이벤트 루프는 브라우저(서버 환경에서는 NodeJS)에 존재합니다.
- 웹 페이지가 화면에 보여지기 위해서는 url을 통해 서버로 부터 리소스(HTML, CSS, JS)를 받아옵니다.
- 리소스를 렌더링 하기위해 브라우저는 `렌더링 엔진`과 `자바스크립트 엔진`을 가지고 있습니다.
- `렌더링 엔진`으로 HTML, CSS를 파싱하여 렌더 트리를 만들고
- `자바스크립트 엔진`으로 JS를 파싱하여 AST를 생성하고 바이트 코드로 변환하여 실행합니다.
- 콜 스택과 힙으로 구성된 `자바스크립트 엔진`은 태스크가 요청되면 콜 스택을 통해 요청된 작업을 순차적으로 실행합니다.
- 여기서 중요한 점은 `자바스크립트 엔진`은 **코드의 평가와 실행만을 담당한다는 것입니다.**
- 즉, 순차적으로 평가된 코드가 실행되도록 하는 역할만 합니다.
- **그렇다면 콜백으로 전달된 비동기 코드는 비동기 처리 후 어떻게 순서를 지정 받고 실행될가요?**
- 이를 위해 브라우저 환경에 내장된 `이벤트 루프`와 `태스크 큐`가 존재합니다.
- `태스크 큐`에는 비동기 함수의 콜백 함수 또는 이벤트 핸들러(setTimeout 등)가 일시적으로 보관되는 영역입니다.
- 추가적으로 프로미스의 후속 처리 메서드(then, catch, finally)를 먼저 처리해주는 `마이크로태스크큐`도 존재합니다.
- `태스크 큐`에 보관된 비동기 함수와 `자바스크립트 엔진`의 `콜스택`을 계속 확인하는게 `이벤트 루프` 입니다.
- `이벤트 루프`는 `자바스크립트 엔진`의 `콜스택`이 비어 있고 태스크 큐에 대기 중인 비동기 함수가 존재한다면
- `태스크 큐`에 대기중인 비동기 함수를 순차적으로 `콜스텍`으로 이동시킵니다. (마이크로태스트큐 우선)
- 콜스텍으로 이동된 비동기 함수는 `자바스크립트 엔진`의 `콜스택`에 들어오게 되면서 실행됩니다.
- 싱글 스레드인 자바스크립트 엔진이 비동기적으로 코드를 실행할 수 있게 해주는 핵심 개념입니다.

## 5. 자바스크립트가 멀티 스레드 처럼 작동하는 원리는?

- 자바스크립트는 싱글 스레드 언어입니다.
- 그럼에도 멀티 스레드처럼 작동하는 이유는 비동기 처리를 해주는 `Web API`와 처리 후 콜 스택으로 넣어주는 `이벤트 루프` 덕분입니다.
- `이벤트 루프`와 `Web API`는 `자바스크립트 엔진`이 아닌 `브라우저(서버 환경에서는 NodeJS)`에 존재합니다.
- 비동기 함수를 자바스크립트 엔진의 콜 스텍에서 호출하면 이후 비동기 작업은 브라우저의 `WEP API`를 통해 처리됩니다.
- **그동안 자바스크립트 엔진의 콜 스텍은 남은 동기적인 코드를 실행합니다.**
- 비동기 작업이 완료되면, 해당 작업의 콜백(또는 Promise 메소드)은 태스크큐(또는 마이크로태스크큐)로 이동합니다.
- `이벤트 루프`는 콜 스택과 태스크큐를 계속해서 감시하고 콜 스택이 비어있다면 태스크큐에서 대기중인 작업을 콜 스택으로 이동시킵니다.
- 콜 스택으로 이동된 콜백(또는 Promise 메소드)이 실행됩니다.
- 자바스크립트 엔진의 콜 스택은 비동기 작업이 Web API를 통해 처리되는 동안 계속해서 남은 동기적인 코드를 실행합니다.
- 때문에 싱글 스레드인 자바스크립트에서도 멀티 스레드처럼 작동할 수 있습니다.
