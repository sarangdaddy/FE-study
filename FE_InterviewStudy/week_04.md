# Week_04

## 1. 개발경험에서 캐시를 활용한 구현사례가 있으면 설명해보세요.

- React Query 라이브러리를 사용한 데이터 캐싱이 있습니다.
- React Query는 패칭한 데이터를 캐시에 보관하고 변경된 사항이 없다면 새로운 API 요청없이 보관중인 캐시를 재사용합니다.
- 이 기능의 동작 방식이 궁금해서 직접 구현을 해보았습니다.
- 캐쉬 매니저라는 헬퍼함수에 패칭된 데이터를 캐쉬하여 보관하는 메서드와 유효성을 검사하는 메서드를 구현하고
- useFetch 커스텀 훅에서 헬퍼함수를 사용하여 보유중인 캐쉬 + 유효하다면 API 요청을 생략하고 캐쉬중인 데이터를 반환하도록 구현했습니다.
- 이외에도 로컬스토리지에 사용자 입력 데이터를 저장하여 인터럽트가 발생해도 데이터를 복원할 수 있도록 구현한 경험이 있습니다.
- 이 또한, 캐시를 활용한 사용자 경험 향상을 고려한 구현 사례라고 생각합니다.

## 2. 좌우로 움직이는 무한 슬라이딩 UI를 만들고 싶습니다. 어떻게 구현할까요?

- 슬라이딩 데이터 수가 고정인지 동적으로 추가되는지를 먼저 고려해야 할 것 같습니다.
- 데이터 수가 고정이라면 처음 렌더링에 슬라이더를 모두 렌더링하고 캐러셀 형태로 보여지는 데이터외에는 뒤에 숨겨줍니다.
- 좌우로 움직일때 css 효과와 함께 첫 혹은 끝 DOM의 위치를 교환합니다.
- 만약 데이터가 동적으로 추가된다면, 새로운 DOM을 생성하지 않고 DOM에 들어가는 데이터를 변경해주는 방법을 채택할 것 같습니다.
- 사용자가 슬라이드를 넘겨 화면에 보이지 않는 슬라이더 DOM의 데이터를 바꾸는 로직을 고려할 것 같습니다.
- 슬라이딩의 경우 DOM 생성과 삭제를 최소화여 성능 최적화와 동시에 사용자 경험을 함께 고려해야 합니다.

## 3. 프런트엔드 빌드에서 처리하는 과정을 요약해서 설명해보세요.

- 빌드는 소스 코드를 배포가능한 상태로 변환하는 과정입니다.
- .env와 같이 보안이 필요한 소스코드를 분리합니다.
- Babel과 같은 트랜스파일러를 사용하여 ES6등의 최신 문법을 호환이 가능한 이전 문법으로 변환합니다.
- Weppack과 같은 번들러를 활용하여 모듈화된 소스코드를 하나의 파일로 합칩니다.
- package.json 파일 내에 스크립트를 정의하여 빌드와 테스트를 자동화 합니다.
- CI/CD 도구를 활용하여 지속적 통합과 지속적 배포를 자동화할 수 있습니다.

## 4. 고차함수는 무엇이고 어떻게 활용했는지 설명해보세요.

- 고차함수는 다른 함수를 인자로 받거나 함수를 결과로 반환하는 함수를 말합니다.
- 이는 함수를 입급객체(값처럼 사용가능한 객체)로 취급하는 언어의 특징입니다.
- 함수를 인자로 받는다는 것은 로직을 함수에 전달할 수 있다는 것으로
- 이는 재사용성과 추상화 수준을 향상시킵니다.
- map의 경우 변환 함수를 인자로 받아 배열의 각 요소에 적용합니다.
- 함수를 결과로 반환한다는 것은 클로저로 생성 당시 환경을 기억하는 함수를 생성할 수 있습니다.
- 이를 활용하여 특정 환경을 기억하는 메서드를 반환하는 헬퍼함수등을 구현하여 
- 필요한 컴포넌트에서는 메서드만을 호출하여 기억되고 있던 객체를 사용하거나 업데이트 할 수 있습니다.

## 5. Promise 패턴은 어떤 장점이 있나요?

- 함수 내에서 비동기로 동작하는 코드를 포함한 함수를 비동기 함수라고 합니다.
- 비동기로 동작하는 코드는 결과가 나중에 나오기에 결과를 비동기 함수에게 콜백해주어야합니다.
- 만약 콜백의 결과로 또 다른 비동기 함수를 호출하고 그 결과를 또 다른 비동기를 호출한다면
- 코드로직이 콜백지옥이 됩니다.
- 콜백지옥은 가독성과 보수성 그리고 에러처리에도 어려움이 많습니다.
- 이를 해결하기 위해 나온 패턴이 Promise 패턴입니다.
- Promise는 then 메서드를 통해 콜백 없이 동기적으로 코드가 작성되도록 해줍니다.
- catch매서드로 에러처리 또한 한번에 가능하도록 도와줍니다.
- 또한, Promise는 상태를 가지고 있습니다. pending, fullfilled, rejected와 같은 상태는
- 비동기 함수의 상태에 따라 로당페이지를 보여주거나 에러 처리를 사용자 친화적으로 할 수 있도록 도와줍니다.

### 5-1. async/await 

- 가독성  
: async/await를 사용하면 비동기 코드가 동기 코드처럼 읽히고 이해하기 쉬워집니다.   
async로 함수를 선언함으로써 해당 함수 내에서 await 키워드를 사용할 수 있게 되고,   
이는 비동기 작업이 마치 순차적인 작업처럼 보이게 해줍니다.

- 보다 깔끔한 에러 처리  
: try/catch 블록을 이용하여 전통적인 동기 코드처럼 에러를 캐치하고 처리할 수 있습니다.  
 이는 .catch() 메서드를 사용하는 것보다 훨씬 직관적이고 명확합니다.

- 중첩된 프로미스 제거  
: async/await를 사용하면 중첩된 .then()과 .catch() 호출을 제거할 수 있어, 코드가 선형적이고 평평하게 유지됩니다.

- 동기적인 흐름 제어    
: await를 사용하면 비동기 작업이 완료될 때까지 함수의 실행을 일시 중지할 수 있으며, 이로 인해 동기적인 흐름 제어가 가능해집니다.

- 디버깅의 용이성  
: async/await는 동기 코드와 유사한 스택 트레이스를 제공하기 때문에, 전통적인 콜백이나 프로미스를 사용할 때보다 디버깅이 더 쉽습니다.

- 조건부 실행과 반복  
: async/await를 사용하면, 조건문과 반복문을 비동기 작업에 쉽게 적용할 수 있으며, 이는 프로미스 체인으로는 어려울 수 있습니다.

- 향상된 성능과 동시성  
: await를 사용하여 필요한 비동기 작업을 순차적으로 실행할 수 있고,  
 Promise.all()을 통해 동시에 실행할 수도 있어, 코드의 성능과 동시성을 최적화할 수 있습니다.

- 코드의 간소화  
: 비동기 함수에서 값을 반환하거나 예외를 발생시킬 때,   
async/await는 프로미스를 자동으로 래핑하고 언래핑(unwrapping)함으로써 코드를 단순화합니다.