# 탈출구

컴포넌트 중 일부는 React 외부의 시스템을 제어하고 동기화해야 할 수 있다.

- 브라우저 API를 사용해 input에 초점을 맞추는 경우
- React 없이 구현된 비디오 플레이어를 재생 및 일시정지하는 경우
- 원격 서버에 연결해서 메시지를 수신해야 할 경우

> React의 `외부`로 나가서 외부 시스템에 연결할 수 있는 탈출구에 대해 알아보자.

## 이 챕터에서 다룰 내용

- 리렌더링하지 않고 정보를 “기억”하는 방법
- React가 관리하는 DOM 엘리먼트에 접근하는 방법
- 컴포넌트를 외부 시스템과 동기화하는 방법
- 컴포넌트에서 불필요한 Effect를 제거하는 방법
- effect의 생명주기가 컴포넌트와 어떻게 다른지
- 일부 값이 Effect를 다시 촉발하는 것을 방지하는 방법
- Effect 재실행 빈도를 줄이는 방법
- 컴포넌트 간 로직을 공유하는 방법

</br>

# ref로 값 참조하기

- 컴포넌트가 특정 정보를 `기억` 하도록 하고 싶지만 해당 정고가 `새 렌더링을 촉발하지 않도록` 하려는 경우 ref를 사용할 수 있다.

## 컴포넌트에 ref 추가하기

1. useRef 훅을 가져온다.

```jsx
import { useRef } from "react";
```

2. useRef 혹을 호출하고 참조할 초기밧을 인자로 전달한다.

```jsx
const ref = useRef(0);
```

3. useRef는 다음과 같은 객체를 반환한다.

```json
{
  "current": 0 // The value you passed to useRef
}
```

- ref.current 속성을 통해 해당 ref의 현재 값에 엑세스할 수 있다.
- 이 값은 읽기와 쓰기가 모두 가능하다.

```jsx
import { useRef } from "react";

export default function Counter() {
  let ref = useRef(0);

  function handleClick() {
    ref.current = ref.current + 1;
    alert("You clicked " + ref.current + " times!");
  }

  return <button onClick={handleClick}>Click me!</button>;
}
```

> `ref`는 React가 추적하지 않는 컴포넌트의 `비밀 주머니`와 같다.

- ref는 숫자 뿐만이 아닌 state와 마찬가지로 문자열, 객체, 함수 등 무엇이든 가리킬 수 있다.
- ref는 current 속성을 읽고 수정할 수 있는 일반 JavaScript 객체다.
- **ref는 state와 마찬가지로 값을 유지하면서 state와는 다르게 컴포넌트가 리렌더링되지 않는다.**

## state와 ref 함께 사용하기 (스톱워치)

```jsx
import { useState, useRef } from "react";

export default function Stopwatch() {
  // 컴포넌트가 새로운 값으로 렌더링 되어야하는 시간은 state로 관리한다.
  const [startTime, setStartTime] = useState(null);
  const [now, setNow] = useState(null);

  // 컴포넌트 렌더링과는 상관 없지만 기억해야하는 interval ID는 ref로 관리한다.
  const intervalRef = useRef(null);

  function handleStart() {
    setStartTime(Date.now());
    setNow(Date.now());

    // setInterval이 호출한 interval ID를 clearInterval()에 제공
    clearInterval(intervalRef.current);
    intervalRef.current = setInterval(() => {
      setNow(Date.now());
    }, 10);
  }

  function handleStop() {
    // setInterval이 호출한 interval ID를 clearInterval()에 제공
    clearInterval(intervalRef.current);
  }

  let secondsPassed = 0;
  if (startTime != null && now != null) {
    secondsPassed = (now - startTime) / 1000;
  }

  return (
    <>
      <h1>Time passed: {secondsPassed.toFixed(3)}</h1>
      <button onClick={handleStart}>Start</button>
      <button onClick={handleStop}>Stop</button>
    </>
  );
}
```

- 렌더링에 정보가 사용되는 경우 해당 정보를 state로 유지한다.
- 이벤트 핸들러만 정보를 필요로 하고 변경해도 다시 렌더링할 필요가 없는 경우 ref를 사용한다.

## ref와 state의 차이점

| refs                                                                       | state                                                                                         |
| -------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------- |
| useRef(initialValue)는 { current: initialValue }을 반환                    | useState(initialValue)는 state 변수의 현재값과 state 설정자함수([value, setValue])를 반환     |
| 변경 시 리렌더링을 촉발하지 않음                                           | 변경 시 리렌더링을 촉발함                                                                     |
| Mutable— 렌더링 프로세스 외부에서 current 값을 수정하고 업데이트할 수 있음 | “Immutable”— state setting 함수를 사용하여 state 변수를 수정해 리렌더링을 대기열에 추가해야함 |
| 렌더링 중에는 current 값을 읽거나 쓰지 않아야 함                           | 언제든지 state를 읽을 수 있음. 각 렌더링에는 변경되지 않는 자체 state snapshot이 있음         |

## ref는 설정자가 없는 일반 state 변수라고 생각하면 된다.

```jsx
// Inside of React
function useRef(initialValue) {
  const [ref, unused] = useState({ current: initialValue });
  return ref;
}
```

## ref를 사용해야 하는 경우

ref는 컴포넌트가 React로부터 `외부로 나가서` 외부 API, 즉 컴포넌트의 형상에 영향을 주지 않는 브라우저 API 등과 통신해야 할 때 사용된다.

- timeout ID 저장
- 다음 페이지에서 다룰 DOM elements 저장 및 조작
- JSX를 계산하는 데 필요하지 않은 다른 객체 저장

> 컴포넌트에 일부 값을 저장해야 하지만 렌더링 로직에는 영향을 미치지 않는 경우에 사용한다.

## ref 모범 사례

- ref를 탈출구(외부 시스템, API 작업)로 취급하자.
- 애플리케이션 로직과 데이터 흐름에는 사용을 조심하자.
- 렌더링 중에는 ref.current를 읽거나 쓰지 말자.(첫 번째 렌더링에만 사용)
- ❓렌더링 중이라는 것은 첫 마운트 제외하고 리랜더링의 경우를 말하는 건가?

> state는 모든 렌더링에서 스냅샷처럼 작동하며 동기적으로 업데이트 되지 않지만 ref는 값을 변경하는 즉시 변경된다.

</br>

# ref로 DOM 조작하기

- React는 렌더링 출력과 일치하도록 DOM을 자동으로 업데이트 해준다.
- 하지만 노드에 초점을 맞추거나 스크롤하거나 크기와 위치를 측정하기 위해 React가 관리하는 DOM요소에 접근해야 할 수도 있다.
- DOM노드에 대한 ref를 만들어서 접근한다.

## 노드에 대한 ref 가져오기

1. useRef 훅을 불러온다.

```jsx
import { useRef } from "react";
```

2. 컴포넌트 내부에서 ref를 선언한다.

```jsx
const myRef = useRef(null);
```

3. **DOM 노드를 가져올 JSX 태그에 ref 속성으로 참조를 전달한다.**

```jsx
<div ref={myRef}>
```

- useRef 훅은 current라고 하는 프로퍼티가 포함된 객체를 반환한다.
- 처음 myRef.current는 null을 가진다.
- React가 `<div>`에 대한 DOM 노드를 생성하면, useRef.current에 노드가 들어간다.
- 노드를 가진 useRef.current는 빌트인 브라우서 API 사용이 가능하다.

```jsx
// 모든 브라우저 API를 사용할 수 있다. 예를 들어:
myRef.current.scrollIntoView();
```

## 텍스트 input에 초점 맞추기

```jsx
import { useRef } from "react";

export default function Form() {
  const inputRef = useRef(null);

  function handleClick() {
    inputRef.current.focus();
  }

  return (
    <>
      // 노드에 ref 전달
      <input ref={inputRef} />
      <button onClick={handleClick}>Focus the input</button>
    </>
  );
}
```

- `<input ref={inputRef} />` input의 DOM 노드를 `inputRef.current`에 넣는다.
- handleClick 함수에서 inputRef.current로부터 `input DOM 노드를 읽어`와서 inputRef.current.focus()로 `focus()를 호출`합니다.

## ref 콜백을 사용하여 refs 목록을 관리하는 방법

필요한 DOM 노드를 ref로 만들어서 사용해봤다.  
하지만, 한 목록의 모든 요소를 사용한다면 어떻게 될까?  
**얼마나 많은 ref가 필요한지 알 수 없는 경우의 방법을 알아보자**

- ref 속성에 함수를 전달해준다. 이를 `ref 콜백`이라고 한다.
- React는 ref를 설정할 떄가 되면 DOM 노드로, 지울 때가 되면 null로 ref 콜백을 호출한다.
- 이를 통해 자신만의 배열(인덱스)이나 Map(ID)로 모든 ref에 접근할 수 있다.

```jsx
import { useRef } from "react";

export default function CatFriends() {
  const itemsRef = useRef(null);

  function scrollToId(itemId) {
    const map = getMap(); // map으로 저장된 itemsRef 가져오기
    const node = map.get(itemId); // map안에서 선택된 id로 node 가져오기
    node.scrollIntoView({
      behavior: "smooth",
      block: "nearest",
      inline: "center",
    });
  }

  function getMap() {
    if (!itemsRef.current) {
      // Initialize the Map on first usage.
      itemsRef.current = new Map();
    }
    return itemsRef.current;
  }

  return (
    <>
      <nav>
        <button onClick={() => scrollToId(0)}>Tom</button>
        <button onClick={() => scrollToId(5)}>Maru</button>
        <button onClick={() => scrollToId(9)}>Jellylorum</button>
      </nav>
      <div>
        <ul>
          {catList.map((cat) => (
            <li
              key={cat.id}
              ref={(node) => {
                const map = getMap();
                if (node) {
                  map.set(cat.id, node);
                } else {
                  map.delete(cat.id);
                }
              }}
            >
              <img src={cat.imageUrl} alt={"Cat #" + cat.id} />
            </li>
          ))}
        </ul>
      </div>
    </>
  );
}

const catList = [];
for (let i = 0; i < 10; i++) {
  catList.push({
    id: i,
    imageUrl: "https://placekitten.com/250/200?image=" + i,
  });
}
```

- 위 예제에서 itemsRef는 하나만의 DOM 노드를 보유하지 않는다.
- DOM 노드들이 모여있는 Map을 보유한다.

```jsx
<li
  key={cat.id}
  ref={node => {
    const map = getMap();
    if (node) {
      // Add to the Map
      map.set(cat.id, node);
    } else {
      // Remove from the Map
      map.delete(cat.id);
    }
  }}
>
```

- catList에서 노드를 만들때 ref map도 업데이트 된다.

## 다른 컴포넌트의 DOM 노드에 접근하기

- 위 예제들에서는 빌트인 컴포넌트 `<input>`, `li` 등에 ref를 주었다.
- 하지만 만들어진 컴포넌트(함수 컴포넌트)에 ref를 넣으면 기본적으로 null이 반환된다.

```jsx
import { useRef } from "react";

// 만들어진 input을 반환하는 함수 컴포넌트
function MyInput(props) {
  return <input {...props} />;
}

export default function MyForm() {
  const inputRef = useRef(null);

  function handleClick() {
    inputRef.current.focus();
  }

  return (
    <>
      <MyInput ref={inputRef} />
      <button onClick={handleClick}>Focus the input</button>
    </>
  );
}
```

```
Warning: Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?
// 경고: 함수 컴포넌트에는 refs를 지정할 수 없습니다. 이 ref에 접근하려는 시도는 실패합니다. React.forwardRef()를 사용하려고 하셨나요?
```

> 기본적으로 React는 한 컴포넌트가 다른 컴포넌트의 DOM 노드에 접근하는 것을 차단하기 때문이다.

- 해결방법으로는 DOM 노드를 다른 컴포넌트가 사용할 수 있도록 설정해야한다.
- 이는 상위 컴포넌트로부터 ref를 전달 받을 수 있도록 하는 것이다.

```jsx
const MyInput = forwardRef((props, ref) => {
  return <input {...props} ref={ref} />;
});
```

- MyInput 컴포넌트를 `forwardRef`를 사용하여 선언하면, props 다음의 두 번째 `ref 인수`에 상위 컴포넌트의 `inputRef`를 받도록 설정한다.
- MyInput은 수신한 ref를 내부의 `<input>`으로 전달한다.

```jsx
import { forwardRef, useRef } from "react";

const MyInput = forwardRef((props, ref) => {
  return <input {...props} ref={ref} />;
});

export default function Form() {
  const inputRef = useRef(null);

  function handleClick() {
    inputRef.current.focus();
  }

  return (
    <>
      <MyInput ref={inputRef} />
      <button onClick={handleClick}>Focus the input</button>
    </>
  );
}
```

> 위와 같은 방식은 버튼, 입력 등과 같은 저수준 컴포넌트에서만 사용하는 것이 좋다.

## DOM 노트 노출을 제한하기

위 예제에서 MyInput은 DOM input 엘리먼트를 노출하고 있다.  
만약 focus()만을 위해서 노출을 하도록 만들고 싶다면 `useImperativeHandle`를 사용할 수 있다.

```jsx
import { forwardRef, useRef, useImperativeHandle } from "react";

const MyInput = forwardRef((props, ref) => {
  const realInputRef = useRef(null);
  useImperativeHandle(ref, () => ({
    // Only expose focus and nothing else
    focus() {
      realInputRef.current.focus();
    },
  }));
  return <input {...props} ref={realInputRef} />;
});

export default function Form() {
  const inputRef = useRef(null);

  function handleClick() {
    inputRef.current.focus();
  }

  return (
    <>
      <MyInput ref={inputRef} />
      <button onClick={handleClick}>Focus the input</button>
    </>
  );
}
```

## React가 ref를 첨부할 때

React에서 모든 업데이트는 두 단계로 나뉜다.

- 렌더링 : React는 컴포넌트를 호출하여 화면에 무엇이 표시되어야 하는지 파악한다.
  - 렌더링 중에는 DOM 노드가 아직 생성되지 않았으므로 ref.current는 null이다.
- 커밋 : React는 DOM에 변경 사항을 적용한다.
  - 커밋 단계에서 ref.current를 설정한다.
  - DOM이 업데이트된 직후 해당 DOM 노드를 다시 설정한다.

## state를 동기식으로 업데이트하기

아래 예제에서 todo 목록이 추가되면 추가된 노드로 스크롤이 이동되게 하고자 한다.

```jsx
import { useState, useRef } from "react";

export default function TodoList() {
  const listRef = useRef(null);
  const [text, setText] = useState("");
  const [todos, setTodos] = useState(initialTodos);

  function handleAdd() {
    const newTodo = { id: nextId++, text: text };
    setText("");
    setTodos([...todos, newTodo]);
    listRef.current.lastChild.scrollIntoView({
      behavior: "smooth",
      block: "nearest",
    });
  }

  return (
    <>
      <button onClick={handleAdd}>Add</button>
      <input value={text} onChange={(e) => setText(e.target.value)} />
      <ul ref={listRef}>
        {todos.map((todo) => (
          <li key={todo.id}>{todo.text}</li>
        ))}
      </ul>
    </>
  );
}

let nextId = 0;
let initialTodos = [];
for (let i = 0; i < 20; i++) {
  initialTodos.push({
    id: nextId++,
    text: "Todo #" + (i + 1),
  });
}
```

- 결과는 추가된 노드위치가 아닌 그 이전 상태의 마지막 노드로 이동된다.
- state는 DOM을 즉시 업데이트 하지 않기 때문이다.

```jsx
setTodos([...todos, newTodo]);
listRef.current.lastChild.scrollIntoView();
```

- setTodos는 업데이트 된 후 재렌더링으로 노드를 추가한다.
- scrollIntoView()는 업데이트 단계에서 진행이 되버린다.
- **`flushSync`로 state 업데이트를 동기적으로 만들 수 있다.**

```jsx
import { useState, useRef } from "react";
import { flushSync } from "react-dom";

export default function TodoList() {
  const listRef = useRef(null);
  const [text, setText] = useState("");
  const [todos, setTodos] = useState(initialTodos);

  function handleAdd() {
    const newTodo = { id: nextId++, text: text };
    flushSync(() => {
      setText("");
      setTodos([...todos, newTodo]);
    });
    listRef.current.lastChild.scrollIntoView({
      behavior: "smooth",
      block: "nearest",
    });
  }

  return (
    <>
      <button onClick={handleAdd}>Add</button>
      <input value={text} onChange={(e) => setText(e.target.value)} />
      <ul ref={listRef}>
        {todos.map((todo) => (
          <li key={todo.id}>{todo.text}</li>
        ))}
      </ul>
    </>
  );
}

let nextId = 0;
let initialTodos = [];
for (let i = 0; i < 20; i++) {
  initialTodos.push({
    id: nextId++,
    text: "Todo #" + (i + 1),
  });
}
```

## ref를 이용한 DOM 조작 모범 사례

- React가 관리하는 DOM 노드를 변경하면 안된다.
- React가 업데이트할 이유가 없는 DOM의 일부는 안전하게 수정할 수 있다.

</br>

# Effect와 동기화 하기

일부 컴포넌트는 외부 시스템과 동기화해야 한다.

- React state를 기반으로 React가 아닌 컴포넌트를 제어할떄
- 서버 연결을 설정할때
- 컴포넌트가 화면에 나타날 때 분석 로그를 보낼때

> Effect를 사용하면 렌더링 이후 일부 코드를 실행할 수 있으며 외부 시스템과 동기화할 수 있다.

## Effect란 무엇이며 이벤트와는 어떤게 다른가

React는 두가지 작업 유형이 존재한다.

- 렌더링 : props와 state를 가져와 JSX를 반환
- 이벤트 핸들러 : 사용자 작업으로 발생하는 사이드 이펙트

> Effect는 사용자 이벤트가 아닌 렌더링 자체로 인해 발생하는 사이드 이펙트를 명시할 수 있다.  
> ex. 서버 연걸

## Effect가 필요하지 않을 수도 있다.

Effect는 일반적으로 React 코드에서 벗어나 외부 시스템과 동기화하는데 사용된다.  
Effect가 아닌 다른 state를 기반으로 일부 state만을 조정하는 경우, Effect가 필요하지 않을 수도 있다.

## Effect 작성방법

### 1. Effect 선언

```jsx
import { useEffect } from "react";

function MyComponent() {
  useEffect(() => {
    // Code here will run after *every* render
    // 여기의 코드는 매 렌더링 후에 실행됩니다.
  });
  return <div />;
}
```

- 컴포넌트가 렌더링될 때마다 React는 화면을 업데이트하고 useEffect 내부의 코드를 실행한다.
- 즉, useEffect는 해당 렌더링이 화면에 반영이 될 때까지 코드 조각의 실행을 “지연”한다.

```jsx
import { useState, useRef, useEffect } from "react";

function VideoPlayer({ src, isPlaying }) {
  const ref = useRef(null);

  useEffect(() => {
    if (isPlaying) {
      ref.current.play();
    } else {
      ref.current.pause();
    }
  });

  return <video ref={ref} src={src} loop playsInline />;
}

export default function App() {
  const [isPlaying, setIsPlaying] = useState(false);
  return (
    <>
      <button onClick={() => setIsPlaying(!isPlaying)}>
        {isPlaying ? "Pause" : "Play"}
      </button>
      <VideoPlayer
        isPlaying={isPlaying}
        src="https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4"
      />
    </>
  );
}
```

- VideoPlayer는 App으로 부터 재생여부 props를 전달받는다.
- Effect 없이 전달받은 props isPlaying으로 동영상을 컨트롤하려고 하면 문제가 발생한다.
- 아직 VideoPlayer의 모든 DOM이 렌더링되지 않았는데, 재생 여부를 묻기 때문이다.

```jsx
if (isPlaying) {
  ref.current.play(); // Calling these while rendering isn't allowed.
} else {
  ref.current.pause(); // Also, this crashes.
}
```

> useEffect는 모든 렌더링이 일어난 후에 발생하기에 이러한 문제를 해결해준다.

### 2. Effect 의존성 지정하기

- 기본적으로 Effect는 `매번` 렌더링 후에 실행된다.
- 특정한 경우에만 Effect가 일어나게 하기위해서는 의존성을 지정해야 한다.

```jsx
useEffect(() => {
  // This runs after every render
  // 렌더시마다 실행됩니다.
});

useEffect(() => {
  // This runs only on mount (when the component appears)
  // 오직 마운트시(컴포넌트가 나타날 때)에만 실행됩니다.
}, []);

useEffect(() => {
  // This runs on mount *and also* if either a or b have changed since the last render
  // 마운트시 뿐만 아니라 a 또는 b가 직전 렌더와 달라졌을 때에도 실행됩니다.
}, [a, b]);
```

- 의존성 배열은 여러 개의 의존성을 포함할 수 있다.

### 3. 필요한 경우 클린업을 추가한다.

채팅 서버에 연결해야 한느 ChatRoom 컴포넌트를 생각해보자.

```jsx
import { useEffect } from "react";
import { createConnection } from "./chat.js";

export default function ChatRoom() {
  useEffect(() => {
    const connection = createConnection();
    connection.connect();
  }, []);
  return <h1>Welcome to the chat!</h1>;
}

export function createConnection() {
  // A real implementation would actually connect to the server
  return {
    connect() {
      console.log("✅ Connecting...");
    },
    disconnect() {
      console.log("❌ Disconnected.");
    },
  };
}
```

- 마운트때 서버를 연결한다.
- **여기서 문제는 마운트 마다 서버에 연결한다는 것이다.**
- 언마운트시 없에야 하는 코드를 추가해야한다.

```jsx
export default function ChatRoom() {
  useEffect(() => {
    const connection = createConnection();
    connection.connect();
    return () => connection.disconnect();
  }, []);
```

> **💡 useEffect에서 반환하는 함수는 컴포넌트가 언마운트될 때 호출되는 클린업 함수다.**
>
> - 이벤트 리스너 제거
> - 네트워크 요청 취소
> - 타이머 해체

❓ 로그인 엄격모드 문제 이걸로....?

## 개발 환경에서 두 번씩 실행되는 Effect를 처리하는 방법은 무엇일까?

- React는 개발 환경에서 버그를 찾기 위해 컴포넌트를 의도적으로 다시 다운트 한다.
- 어떻게 하면 Effect를 한 번만 실행할 수 있는가? 가 아닌
- **어떻게 다시 마운트한 후에도 Effect가 잘 작동하도록 수정하는가?** 이다.

> 클린업 함수를 구현하는 것이다. 클린업 함수는 Effect가 수행 중이던 작업을 중지하거나 취소해야 한다.

### React가 아닌 위젯 제어하기

- 지도와 같은 UI 위젯은 React로 작성하지 않은 경우다.
- 지도의 확대/축소를 state 변수와 동기화한다.

```jsx
useEffect(() => {
  const map = mapRef.current;
  map.setZoomLevel(zoomLevel);
}, [zoomLevel]);
```

- 이 경우에는 클린업이 필요하지 않다.
- 두번 호출해도 아무러 문제가 없기 때문이다.
- 더욱이 상용 환경에서는 불필요하게 다시 마운트 되지 않는다.

아래의 경우는 두 번 연속으로 호출하면 안된다.

```jsx
useEffect(() => {
  const dialog = dialogRef.current;
  dialog.showModal();
  return () => dialog.close();
}, []);
```

- 브라우저 빌트인 요소인 `<dialog>`는 `showModal()`를 두번 호출하면 에어가 발생한다.
- 개발 중에 Effect는 showModal()을 호출한 다음 즉시 close()를 호출하고, 다시 showModal()을 호출한다.
- 이는 상용 환경에서 볼 수 있는 것처럼 showModal()을 한 번 호출하는 것과 체감상 동일하다.

### 이벤트 구독하기

- Effect가 무언가를 구독하는 경우, 클린업 함수는 구독을 취소해야 한다.

```jsx
useEffect(() => {
  function handleScroll(e) {
    console.log(window.scrollX, window.scrollY);
  }
  window.addEventListener("scroll", handleScroll);
  return () => window.removeEventListener("scroll", handleScroll);
}, []);
```

- 개발 중에 Effect는 addEventListener()를 호출한 다음 즉시 removeEventListener()를 호출한다. - 그런 다음 동일한 핸들러를 사용하여 다시 addEventListener()를 사용함으로써, 한 번에 하나의 구독만 활성화 되도록 한다.
- 이는 상용 환경에서 addEventListener()를 한 번만 호출하는 것과 체감상 동일한다.

### 애니메이션 촉발하기

- Effect가 무언가를 애니메이션하는 경우 클린업 함수는 애니메이션을 초기값으로 재설정해야 한다.

```jsx
useEffect(() => {
  const node = ref.current;
  node.style.opacity = 1; // Trigger the animation
  // 애니메이션 촉발
  return () => {
    node.style.opacity = 0; // Reset to the initial value
    // 초기값으로 재설정
  };
}, []);
```

- 만약 트위닝을 지원하는 서드파티 애니메이션 라이브러리를 사용하는 경우라면, 클린업 함수에서 타임라인을 초기 state로 재설정해줘야 한다.

### 데이터 페칭하기

- Effect가 무언가를 페치하면 클린업 함수는 페치를 중단하거나 그 결과를 무시해야 한다.

```jsx
useEffect(() => {
  let ignore = false;

  async function startFetching() {
    const json = await fetchTodos(userId);
    if (!ignore) {
      setTodos(json);
    }
  }

  startFetching();

  return () => {
    ignore = true;
  };
}, [userId]);
```

- 이미 발생한 네트워크 요청을 "실행 취소" 할 수는 없다.
- 클린업 함수에서 더 이상 `관련이 없는 페치`가 애플리케이션에 계속 영향을 미치지 않도록 해야한다.
- userId가 'Alice'에서 'Bob'으로 변경되면 클린업은 'Alice' 응답이 'Bob' 이후에 도착하더라도 이를 무시하도록 한다.

> 상용 환경에서는 요청이 하나만 있다. 개발 중인 두 번째 요청이 귀찮은 경우 가장 좋은 방법은 요청을 중복 제거하고 컴포넌트 간에 응답을 `캐시하는 솔루션`을 사용하는 것이다.

### 분석 보내기

```jsx
useEffect(() => {
  logVisit(url); // Sends a POST request
}, [url]);
```

### Effect가 아닌 경우 : 애플리케이션 초기화하기

- 일부 로직은 애플리케이션이 시작될 때 한 번만 실행되어야 한다.
- 이런 로직은 컴포넌트 외부에 넣을 수 있다.

```jsx
if (typeof window !== "undefined") {
  // Check if we're running in the browser.
  // 실행환경이 브라우저인지 여부 확인
  checkAuthToken();
  loadDataFromLocalStorage();
}

function App() {
  // ...
}
```

### Effect가 아닌 경우 : 제품 구매하기

```jsx
useEffect(() => {
  // 🔴 Wrong: This Effect fires twice in development, exposing a problem in the code.
  // 🔴 틀렸습니다: 이 Effect는 개발모드에서 두 번 실행되며, 문제를 일으킵니다.
  fetch("/api/buy", { method: "POST" });
}, []);
```

- 제품을 두 번 사면 안된다.
- 이 로직은 Effect에서 제거되어야 한다.
- 구매는 렌더링으로 인한 것이 아니다. `특정 상호 작용`으로 인해 발생한다.

```jsx
function handleClick() {
  // ✅ Buying is an event because it is caused by a particular interaction.
  // ✅ 구매는 특정 상호작용으로 인해 발생하므로 이벤트입니다.
  fetch("/api/buy", { method: "POST" });
}
```

## 요약

- 이벤트와 달리 Effect는 특정 상호 작용이 아닌 렌더링 자체에 의해 발생합니다.
- Effect를 사용하면 일부 외부 시스템(서드파티 API, 네트워크 등)과 컴포넌트를 동기화할 수 있습니다.
- 기본적으로 Effect는 모든 렌더링 후에 실행됩니다(초기 렌더링 포함).
- React는 모든 의존성이 마지막 렌더링 시점과 동일한 값을 갖는 경우 Effect를 건너뜁니다.
- 의존성을 “선택”할 수는 없습니다. 그들은 Effect 내부의 코드에 의해 결정됩니다.
- 빈 의존성 배열([])은 컴포넌트 “마운팅”, 즉,화면에 추가되는 시점에 대응합니다.
- Strict 모드에서 React는 컴포넌트를 두 번 마운트하여(개발 중인 경우에만!) Effect를 스트레스 테스트합니다.
- 다시 마운트를 수행함으로 인해 Effect가 깨지는 경우, 클린업 함수를 구현해야 합니다.
- React는 다음 Effect가 실행되기 전 및 마운트 해제 시점에 클린업 함수를 호출합니다.

</br>

# Effect가 필요하지 않을 수도 있다.

- Effect는 React 페러다임에서 벗어날 수 있는 탈출구다.
- Efeect는 외부로 나가서 컴포넌트를 위젯, 네트워크, 브라우저 DOM과 같은 외부 시스템과 동기화 할 수 있다.
- 외부 시스템이 관여하지 않는 경우 (\*\*컴포넌트의 state를 업데이트 하는 경우)에는 Effect가 필요하지 않다.

## 불필요한 Effect를 제거하는 방법

다음 두가지의 경우 Effect가 필요하지 않은 흔한 경우다.

1. 렌더링을 위해 데이터를 변환하는 경우 Effect는 필요하지 않다.
2. 사용자 이벤트를 처리하는 데에 Effect는 필요하지 않다.

### props 또는 state에 따라 state 업데이트하기

```jsx
function Form() {
  const [firstName, setFirstName] = useState("Taylor");
  const [lastName, setLastName] = useState("Swift");

  // 🔴 Avoid: redundant state and unnecessary Effect
  // 🔴 이러지 마세요: 중복 state 및 불필요한 Effect
  const [fullName, setFullName] = useState("");
  useEffect(() => {
    setFullName(firstName + " " + lastName);
  }, [firstName, lastName]);
  // ...
}
```

- 위 방식은 이전 fullName을 렌더링하고 업데이트된 fullName을 다시 렌더링한다.

```jsx
function Form() {
  const [firstName, setFirstName] = useState("Taylor");
  const [lastName, setLastName] = useState("Swift");
  // ✅ Good: calculated during rendering
  // ✅ 좋습니다: 렌더링 과정 중에 계산
  const fullName = firstName + " " + lastName;
  // ...
}
```

- 기존 state로 계산할 수 있는 것은 새로운 state가 필요하지 않다.
- useEffect 없이 렌더링 중에 계산할 수 있다.

### 고비용 계산 캐싱하기

- 아래 컴포넌트는 props로 받은 `todos`를 `filter` prop에 따라 필터링하여 visibleTodos를 계산한다.
- 이 결과를 state 변수에 저장하고 Effect에서 업데이트하고 싶을 수도 있다.

```jsx
function TodoList({ todos, filter }) {
  const [newTodo, setNewTodo] = useState("");

  // 🔴 Avoid: redundant state and unnecessary Effect
  // 🔴 이러지 마세요: 중복 state 및 불필요한 Effect
  const [visibleTodos, setVisibleTodos] = useState([]);
  useEffect(() => {
    setVisibleTodos(getFilteredTodos(todos, filter));
  }, [todos, filter]);

  // ...
}
```

- 위 코드도 불필요한 작업이다.

```jsx
function TodoList({ todos, filter }) {
  const [newTodo, setNewTodo] = useState("");
  // ✅ This is fine if getFilteredTodos() is not slow.
  // ✅ getFilteredTodos()가 느리지 않다면 괜찮습니다.
  const visibleTodos = getFilteredTodos(todos, filter);
  // ...
}
```

- 위 코드로 문제는 없다.
- 하지만 getFilteredTodos()가 느리거나 todos가 많은 경우 다른 state 변경에서 다시 계산하는 것을 방지할 수 있다.

```jsx
import { useMemo, useState } from "react";

function TodoList({ todos, filter }) {
  const [newTodo, setNewTodo] = useState("");
  // ✅ Does not re-run getFilteredTodos() unless todos or filter change
  // ✅ todos나 filter가 변하지 않는 한 getFilteredTodos()가 재실행되지 않음
  const visibleTodos = useMemo(
    () => getFilteredTodos(todos, filter),
    [todos, filter]
  );
  // ...
}
```

- 이럴 땐 값비싼 계산을 `useMemo` 훅으로 감싸서 `캐시`(또는 “메모화 (memoize)”)할 수 있다.
- 이렇게 하면 todos나 filter가 변경되지 않는 한 내부 함수가 다시 실행되지 않기를 원한다는 것을 React에 알린다.

```jsx
console.time("filter array");
const visibleTodos = useMemo(() => {
  return getFilteredTodos(todos, filter); // Skipped if todos and filter haven't changed
}, [todos, filter]);
console.timeEnd("filter array");
```

- 시간을 측정해서 1ms 이상이라면 캐싱하는 것이 좋다
- useMemo는 첫번째 렌더링을 빠르게 만들지는 않는다, 업데이트 시 불필요한 작업을 건너뛰게 해준다.

### props가 변경될 때 일부 state 조정하기

```jsx
function List({ items }) {
  const [isReverse, setIsReverse] = useState(false);
  const [selection, setSelection] = useState(null);

  // 🔴 Avoid: Adjusting state on prop change in an Effect
  // 🔴 이러지 마세요: prop 변경시 Effect에서 state 조정
  useEffect(() => {
    setSelection(null);
  }, [items]);
  // ...
}
```

```jsx
function List({ items }) {
  const [isReverse, setIsReverse] = useState(false);
  const [selectedId, setSelectedId] = useState(null);
  // ✅ Best: Calculate everything during rendering
  // ✅ 가장 좋음: 렌더링 중에 모든 값을 계산
  const selection = items.find((item) => item.id === selectedId) ?? null;
  // ...
}
```

### 이벤트 핸들러 간 로직 공유

```jsx
function ProductPage({ product, addToCart }) {
  // 🔴 Avoid: Event-specific logic inside an Effect
  // 🔴 이러지 마세요: Effect 내부에 특정 이벤트에 대한 로직 존재
  useEffect(() => {
    if (product.isInCart) {
      showNotification(`Added ${product.name} to the shopping cart!`);
    }
  }, [product]);

  function handleBuyClick() {
    addToCart(product);
  }

  function handleCheckoutClick() {
    addToCart(product);
    navigateTo("/checkout");
  }
  // ...
}
```

- 컴포넌트가 사용자에게 표시되었기 때문에 실행되어야 하는 코드에만 Effect를 사용한다.
- 사용자가 버튼을 눌렀기 때문에 일어나는 이벤트는 이벤트 핸들러에서 호출한다.

```jsx
function ProductPage({ product, addToCart }) {
  // ✅ Good: Event-specific logic is called from event handlers
  // ✅ 좋습니다: 이벤트 핸들러 안에서 각 이벤트별 로직 호출
  function buyProduct() {
    addToCart(product);
    showNotification(`Added ${product.name} to the shopping cart!`);
  }

  function handleBuyClick() {
    buyProduct();
  }

  function handleCheckoutClick() {
    buyProduct();
    navigateTo("/checkout");
  }
  // ...
}
```

### POST 요청 보내기

```jsx
function Form() {
  const [firstName, setFirstName] = useState("");
  const [lastName, setLastName] = useState("");

  // ✅ Good: This logic should run because the component was displayed
  // ✅ 좋습니다: '컴포넌트가 표시되었기 때문에 로직이 실행되어야 하는 경우'에 해당
  useEffect(() => {
    post("/analytics/event", { eventName: "visit_form" });
  }, []);

  // 🔴 Avoid: Event-specific logic inside an Effect
  // 🔴 이러지 마세요: Effect 내부에 특정 이벤트에 대한 로직 존재
  const [jsonToSubmit, setJsonToSubmit] = useState(null);
  useEffect(() => {
    if (jsonToSubmit !== null) {
      post("/api/register", jsonToSubmit);
    }
  }, [jsonToSubmit]);

  function handleSubmit(e) {
    e.preventDefault();
    setJsonToSubmit({ firstName, lastName });
  }
  // ...
}
```

- 두 번째 POST 요청은 사용자가 버튼을 누를 때 일어나야한다.
- Effect가 아닌 이벤트 핸들러로 이동해야 한다.

```jsx
function Form() {
  const [firstName, setFirstName] = useState("");
  const [lastName, setLastName] = useState("");

  // ✅ Good: This logic runs because the component was displayed
  // ✅ 좋습니다: '컴포넌트가 표시되었기 때문에 로직이 실행되어야 하는 경우'에 해당
  useEffect(() => {
    post("/analytics/event", { eventName: "visit_form" });
  }, []);

  function handleSubmit(e) {
    e.preventDefault();
    // ✅ Good: Event-specific logic is in the event handler
    // ✅ 좋습니다: 이벤트 핸들러 안에서 특정 이벤트 로직 호출
    post("/api/register", { firstName, lastName });
  }
  // ...
}
```

### 애플리케이션 초기화하기

- 로그인과 관련된 로직은 앱이 로드도리 때 한 번만 실행되어야 한다.
- 이를 위해 최상위 컴포넌트의 Effect에 배치하는 경우가 있다.

```jsx
function App() {
  // 🔴 Avoid: Effects with logic that should only ever run once
  // 🔴 이러지 마세요: 한 번만 실행되어야 하는 로직이 포함된 Effect
  useEffect(() => {
    loadDataFromLocalStorage();
    checkAuthToken();
  }, []);
  // ...
}
```

- 하지만 개발중에는 `두 번` 실행된다. (엄격모드)
- 인증 토큰이 무효화 되는 등의 문제가 발생할 수 있다.
- 일부 로직이 `앱 로드당` 한 번 실행되어야 하는 경우, 최상위 변수를 추가하여 이미 실행되었는지 여부를 추적한다.

```jsx
let didInit = false;

function App() {
  useEffect(() => {
    if (!didInit) {
      didInit = true;
      // ✅ Only runs once per app load
      // ✅ 앱 로드당 한 번만 실행됨
      loadDataFromLocalStorage();
      checkAuthToken();
    }
  }, []);
  // ...
}
```

- 모듈 초기화 중이나 앱 렌더링 전에 실행할 수도 있다.

```jsx
if (typeof window !== "undefined") {
  // Check if we're running in the browser.
  // 브라우저에서 실행중인지 확인
  // ✅ Only runs once per app load
  // ✅ 앱 로드당 한 번만 실행됨
  checkAuthToken();
  loadDataFromLocalStorage();
}

function App() {
  // ...
}
```

> 앱 전체 초기화 로직은 App.js와 같은 루트 컴포넌트 모듈이나 애플리케이션의 엔트리 포인트에 유지하는것이 좋다.

### 외부 스토어 구독하기

- 때로는 컴포넌트가 React state 외부의 일부 데이터를 구독해야 할 수도 있다.
- 서드파티 라이브러리나 브라우저 빌트인 API에서 데이터를 가져와야 할 수도 있다.
- 이 데이터는 React가 모르는 사이에 변경될 수도 있는데, 그럴 땐 수동으로 컴포넌트가 해당 데이터를 구독하도록 해야 한다.
- 이 작업은 종종 Effect에서 수행한다.

```jsx
function useOnlineStatus() {
  // Not ideal: Manual store subscription in an Effect
  // 이상적이지 않음: Effect에서 수동으로 store 구독
  const [isOnline, setIsOnline] = useState(true);
  useEffect(() => {
    function updateState() {
      setIsOnline(navigator.onLine);
    }

    updateState();

    window.addEventListener("online", updateState);
    window.addEventListener("offline", updateState);
    return () => {
      window.removeEventListener("online", updateState);
      window.removeEventListener("offline", updateState);
    };
  }, []);
  return isOnline;
}

function ChatIndicator() {
  const isOnline = useOnlineStatus();
  // ...
}
```

- 여기서 컴포넌트는 외부 데이터 저장소(이 경우 브라우저 navigator.onLine API)에 구독한다.
- 브라우저에서 해당 데이터 저장소의 값이 변경될 때마다 컴포넌트는 해당 state를 업데이트한다.

> Effect를 사용하는 것이 일반적이지만, React에는 외부 저장소를 구독하기 위해 특별히 제작된 훅이 있다.  
> Effect를 삭제하고 `useSyncExternalStore`호출로 대체하자.

```jsx
function subscribe(callback) {
  window.addEventListener("online", callback);
  window.addEventListener("offline", callback);
  return () => {
    window.removeEventListener("online", callback);
    window.removeEventListener("offline", callback);
  };
}

function useOnlineStatus() {
  // ✅ Good: Subscribing to an external store with a built-in Hook
  // ✅ 좋습니다: 빌트인 훅에서 외부 store 구독
  return useSyncExternalStore(
    subscribe, // React won't resubscribe for as long as you pass the same function
    // React는 동일한 함수를 전달하는 한 다시 구독하지 않음
    () => navigator.onLine, // How to get the value on the client
    // 클라이언트에서 값을 가져오는 방법
    () => true // How to get the value on the server
    // 서버에서 값을 가져오는 방법
  );
}

function ChatIndicator() {
  const isOnline = useOnlineStatus();
  // ...
}
```

### 데이터 페칭하기

- 많은 앱이 데이터 페칭을 시작하기 위해 Effect를 사용한다.
- 이와 같은 데이터 페칭 Effect를 작성하는 것은 매우 일반적이다.

```jsx
function SearchResults({ query }) {
  const [results, setResults] = useState([]);
  const [page, setPage] = useState(1);

  useEffect(() => {
    // 🔴 Avoid: Fetching without cleanup logic
    // 🔴 이러지 마세요: 클린업 없이 fetch 수행
    fetchResults(query, page).then((json) => {
      setResults(json);
    });
  }, [query, page]);

  function handleNextPageClick() {
    setPage(page + 1);
  }
  // ...
}
```

- 이 패치를 이벤트 핸들러로 옮길 필요는 없다.
- page와 query가 어디에서 오는지는 중요하지 않다.
- 이 컴포넌트가 표시되는 동안 현재의 page 및 query에 대한 네트워크 데이터와 results의 동기화가 유지되면 된다.
- 다만, 위 코드에는 버그가 존재한다.
- "hello"를 빠르게 입력한다고 하면 "h", "he" 에서 페칭이 수향된다.
- **응답이 어떤 순서로 오는지 알 수 없다.**

> 이를 `경쟁 조건` 이라고 한다.

- 경쟁 조건을 수정하기 위해서는 오래된 응답을 무시하도록 `클린업 함수`를 추가해야 한다.

```jsx
function SearchResults({ query }) {
  const [results, setResults] = useState([]);
  const [page, setPage] = useState(1);
  useEffect(() => {
    let ignore = false;
    fetchResults(query, page).then((json) => {
      if (!ignore) {
        setResults(json);
      }
    });
    return () => {
      ignore = true;
    };
  }, [query, page]);

  function handleNextPageClick() {
    setPage(page + 1);
  }
  // ...
}
```

- 이렇게 하면 Effect가 데이터를 페치할 때 마지막으로 요청된 응답을 제외한 모든 응답이 무시된다.

## 요약

- 렌더링 중에 무언가를 계산할 수 있다면 Effect가 필요하지 않습니다.
- 비용이 많이 드는 계산을 캐시하려면 useEffect 대신 useMemo를 추가하세요.
- 전체 컴포넌트 트리의 state를 재설정하려면 다른 key를 전달하세요.
- prop 변경에 대한 응답으로 특정 state 일부를 조정하려면 렌더링 중에 설정하세요.
- 컴포넌트가 표시되었기 때문에 실행해야 하는 코드는 Effect에 있어야 하고, 나머지는 이벤트에 있어야 합니다.
- 여러 컴포넌트의 state를 업데이트해야 하는 경우 단일 이벤트에서 처리하는 것이 좋습니다.
- 여러 컴포넌트에서 state 변수를 동기화하려고 할 때마다 state 끌어올리기를 고려하세요.
- Effect로 데이터를 페치할 수 있지만, 경쟁 조건을 피하기 위해 클린업 로직을 구현해야 합니다.

</br>

# 반응형 Effect의 생명주기

- Effect는 동기화를 시작하고 나중에 동기화를 중지하는 작업을 한다.
- 이 사이클은 시간이 지남에 따라 변하는 props와 state에 의존하는 Effect의 경우 여러번 발생한다.
- React는 Effect의 의존성을 올바르게 지정했는지 확인하는 린터 규칙을 제공한다.
- 이렇게 하면 Effect가 최신 props와 state에 동기화된다.

## Effect의 생명주기

- Effect를 컴포넌트의 생명주기와 독립적으로 생각하자.
- Effect는 외부 시스템을 현재 props 및 state에 동기화 하는 방법을 설명한다.

```jsx
const serverUrl = "https://localhost:1234";

function ChatRoom({ roomId }) {
  useEffect(() => {
    // 외부와 동기화
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      // 외부와 동기화 해제
      connection.disconnect();
    };
  }, [roomId]);
  // ...
}
```

- 일반적으로는 컴포넌트가 마운트 되면 동기화, 언마운트되면 동기화 해제라고 생각 할 수 있다.
- **하지만 컴포넌트가 마운트된 상태에서 동기화를 여러번 시작하고 중지해야 할 수도 있다.**

## 동기화가 여러번 수행되는 이유

- 사용자가 채팅방에 들어가면 채팅방과 동기화를 실행한다.

```jsx
const connection = createConnection(serverUrl, roomId); // Connects to the "general" room
connection.connect();
```

- 사용자가 다른 채팅방으로 들어간다.
- 이 시점에서 이전 방과 동기화가 되어 있는 상태가 유지된다.
- 여기서 React는 이전방의 동기화를 해지하고 새로운 방과 `다시 동기화`를 원한다.

## React가 Effect를 재동기화 하는 방법

- 클린업 함수로 동기화를 해제한다.
- roomId가 다른 방으로 상태가 변했기에 클린업이 발동된다.
- 새로운 roomId로 재동시화를 한다.

```jsx
function ChatRoom({ roomId /* "general" */ }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId); // Connects to the "general" room
    connection.connect();
    return () => {
      connection.disconnect(); // Disconnects from the "general" room
    };
    // ...
```

### 컴포넌트 관점

1. roomId가 "general"로 설정된 상태로 ChatRoom이 마운트됨  
   1-1. Effect가 "general" 방에 연결됨
2. roomId가 "travel"로 설정된 상태로 ChatRoom이 업데이트됨  
   2-2. Effect가 "general" 방과의 연결이 끊어지고 "travel" 방에 연결됨
3. roomId가 "music"로 설정된 상태로 ChatRoom이 업데이트됨  
   3-3. Effect가 "travel" 방과의 연결이 끊어지고 "music" 방에 연결됨
4. ChatRoom 마운트 해제됨  
   4-4. Effect가 "music" 방과의 연결이 끊어짐

❓ roomId가 바뀌면 클린업이 실행되는 이유가 모지? -> 엄격모드?  
❓ 'A' 방으로 prop을 받으면 Effect로 동기화 (연결)  
❓ 'B' 방으로 prop이 바뀌면 Effect는 다시 동기화만 실행? (클린업은 언제?)  
❓ 즉, 연결 해제는 언제 일어나는 거지?

```
이 클린업 함수는 다음 두 가지 시나리오에서 호출됩니다:

의존성 배열 변경: useEffect의 두 번째 인자로 전달된 배열인 [roomId, serverUrl] 내의 값 중 하나가 변경될 경우, 이전 useEffect의 실행에서 반환된 클린업 함수가 호출됩니다. 그런 다음, 새로운 값으로 useEffect의 본문이 다시 실행됩니다.

컴포넌트 언마운트: 이 useEffect를 포함하고 있는 컴포넌트가 React 트리에서 제거되거나 "언마운트"될 때, 클린업 함수가 호출됩니다.

이 경우, 클린업 함수는 연결을 끊는 역할을 하므로, roomId 또는 serverUrl이 변경되거나 컴포넌트가 언마운트될 때 해당 연결이 종료됩니다.
```

### Effect 관점

1. Effect가 "general" 방에 연결됨 (연결이 끊어질 때까지)
2. Effect가 "travel" 방에 연결됨 (연결이 끊어질 때까지)
3. Effect가 "music" 방에 연결됨 (연결이 끊어질 때까지)

> Effect는 `시작/중지 사이클` 관점으로 바라보는 것이 좋다.

## React가 Effect의 재동기화 필요성을 인식하는 방법

- `의존성 배열`로 인식한다.

## 각각의 Effect는 별도의 동기화 프로세스를 나타낸다.

- 동일한 의존성 배열로 일어나는 다른 동기화가 필요할 수 있다.
- `프로세스`가 다르다면 별도의 Effect로 만들어 주어야 한다.

```jsx
function ChatRoom({ roomId }) {
  useEffect(() => {
    logVisit(roomId);
  }, [roomId]);

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    // ...
  }, [roomId]);
  // ...
}
```

## 컴포넌트 본문에서 선언된 모든 변수는 반응형이다.

- props와 state만 반응형 값인 것은 아니다. 이들로부터 계산하는 값들 역시 반응형이다.
- Effect에서 `읽은` 모든 반응형 값은 의존성 배열에 포함되어야 한다.

> 컴포넌트 내부의 모든 값(컴포넌트 본문의 props, state, 변수 포함)은 반응형이다. 모든 반응형 값은 다시 렌더링할 때 변경될 수 있으므로 반응형 값을 Effect의 의존성으로 포함시켜야 한다 ❓ -> 모든???????

## 요약

- 컴포넌트는 마운트, 업데이트, 마운트 해제할 수 있습니다.
- 각 Effect는 주변 컴포넌트와 별도의 생명주기를 가집니다.
- 각 Effect는 시작 및 중지 할 수 있는 별도의 동기화 프로세스를 설명합니다.
- Effect를 작성하고 읽을 때는 컴포넌트의 관점(마운트, 업데이트 또는 마운트 해제 방법)이 - 아니라 각 개별 Effect의 관점(동기화 시작 및 중지 방법)에서 생각해야 합니다.
- 컴포넌트 본문 내부에 선언된 값은 “반응형”입니다.
- 반응형 값은 시간이 지남에 따라 변경될 수 있으므로 Effect를 다시 동기화해야 합니다.
- 린터는 Effect 내부에서 사용된 모든 반응형 값이 의존성으로 지정되었는지 확인합니다.
- 린터에 의해 플래그가 지정된 모든 오류는 합법적인 오류입니다. 규칙을 위반하지 않도록 코드를 수정할 수 있는 방법은 항상 있습니다.

</br>

# 이벤트와 Effect 분리하기

- 이벤트 핸들러는 같은 상호 작용을 다시 수행할 때만 다시 실행된다.
- 이벤트 핸들러와 달리, Effect는 prop 또는 state 변수와 같은 일부 값을 마지막 렌더링 때와 다른 값으로 읽게 되면 다시 동기화된다.
- 때로는 일부 값에 대한 응답으로 다시 실행되는 Effect와 그렇지 않은 Effect의 혼합이 필요할 때도 있다.
- 이를 어떻게 수행할 수 있는지 알아보자.

## 이벤트 핸들러와 Effect 중 선택하기

- 채팅방으로 생각해보자.
  - 1️⃣ 컴포넌트는 선택한 채팅방에 자동으로 연결되어야 한다.
  - 2️⃣ “전송” 버튼을 클릭하면, 채팅에 메시지를 전송해야 한다.
- 이벤트 핸들러를 사용할지, Effectf를 사용할지는 **코드가 실행되어야하는 이유**를 생각해야한다.

### 1️⃣ Effect는 동기화가 필요할 때마다 실행된다.

```jsx
function ChatRoom({ roomId }) {
  // ...
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, [roomId]);
  // ...
}
```

- 코드가 실행되어야 하는 이유에 사용자의 상호작용은 관여하지 않는다.
- 사용자가 수행한 특정 상호작용과는 무관하게, 항상 현재 선택된 채팅 서버에 대한 활성화된 연결이 있음을 확신할 수 있다.
- 사용자가 다른 채팅방을 선택하거나 다른 화면으로 이동했다가 다시 돌아와도 Effect가 현재 선택된 방과 동기화되어 컴포넌트에 항상 현재 선택된 채팅서버가 연결된 상태가 유지된다.
- 또한, 필요할 때마다 다시 연결할 수 있다.

### 2️⃣ 이벤트 핸들러는 특정 상호 작용에 대한 응답으로 실행된다.

```jsx
function ChatRoom({ roomId }) {
  const [message, setMessage] = useState("");
  // ...
  function handleSendClick() {
    sendMessage(message);
  }
  // ...
  return (
    <>
      <input value={message} onChange={(e) => setMessage(e.target.value)} />
      <button onClick={handleSendClick}>Send</button>;
    </>
  );
}
```

- 사용자 관점에서 메시지를 보내는 것은 특정 “전송” 버튼을 클릭했기 때문에 발생되어야 한다.
- 메시지가 다른 시간이나 다른 이유로 보내지면 사용자들은 불편하다.
- 이것이 메시지를 보내는 것이 이벤트 핸들러여야하는 이유다.

## 반응형 값 및 반응형 로직

컴포넌트 본문 내부에 선언된 props, state, 변수를 `반응형 값` 이라고 한다.

### 이벤트 핸들러 내부의 로직은 반응형이 아니다.

사용자가 동일한 상호작용(예: 클릭)을 다시 수행하지 않는 한 다시 실행되지 않는다. 이벤트 핸들러는 변경에 “반응”하지 않고 반응형 값을 읽을 수 있다.

### Effect 내부의 로직은 반응형이다.

Effect에서 반응형 값을 읽는 경우 의존성으로 지정해야 한다. 그런 다음 리렌더링으로 인해 해당 값이 변경되면 React는 새 값으로 Effect의 로직을 다시 실행한다.

## Effect에서 비반응형 로직 추출하기

반응형 로직과 빈반응형 로직을 함께 사용한다면 어떻게 될까?

```jsx
import { useState, useEffect } from 'react';
import { createConnection, sendMessage } from './chat.js';
import { showNotification } from './notifications.js';

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId, theme }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.on('connected', () => {
      showNotification('Connected!', theme);
    });
    connection.connect();
    return () => connection.disconnect();
  }, [roomId, theme]);
```

- roomId가 변경(반응형)되면 새로운 연결이 이루어 진다.
- 연길이 이루어지면 알림창이 뜬다.
- 알림창에 색모드를 부여하고 싶어서 theme를 전달받고 useEffect에 반응형으로 부여한다.
- 실행은 잘 되지만, 색이 변경될때마다 의존성 문제로 연결도 자시 실행된다.

```jsx
// ...
showNotification("Connected!", theme);
// ...
```

위 코드는 `비반응형`으로 분히되어야 한다.

### useEffectEvent

```jsx
function ChatRoom({ roomId, theme }) {
  const onConnected = useEffectEvent(() => {
    showNotification('Connected!', theme);
  });

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.on('connected', () => {
      onConnected();
    });
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]); // ✅ All dependencies declared
  // ...
```

- 여기서 onConnected는 Effect Event라고 불리며, Effect 로직의 일부이지만 이벤트 핸들러처럼 동작한다.
- 그 내부의 로직은 반응형으로 동작하지 않으며, 항상 props와 state의 최신 값을 “확인”한다.

> Effect Event는 이벤트 핸들러와 매우 유사하다고 생각할 수 있다.  
> 가장 큰 차이점은 이벤트 핸들러는 사용자 상호작용에 대한 응답으로 실행되는 반면, Effect Event는 `Effect에서 사용자가 촉발`한다는 점이다.  
> Effect Event를 사용하면 Effect의 반응성과 반응형으로 동작해서는 안 되는 코드 사이의 “사슬을 끊을 수 있다”.

### EffectEvent로 최신 props 및 state 읽기

```jsx
function Page({ url }) {
  const { items } = useContext(ShoppingCartContext);
  const numberOfItems = items.length;

  const onVisit = useEffectEvent((visitedUrl) => {
    logVisit(visitedUrl, numberOfItems);
  });

  useEffect(() => {
    onVisit(url);
  }, [url]); // ✅ All dependencies declared
  // ...
}
```

- Effect는 반응형이다.
- Effect 내부의 코드는 url prop을 사용하므로, Effect는 다른 url로 다시 렌더링할 때마다 다시 실행된다.
- 그러면 onVisit EffectEvent가 호출된다.
- 여기서 onVisit는 EffectEvent다. 그 안의 코드는 **반응형이 아니다.**
- 때문에 변경 시 주변 코드가 다시 실행될 것을 걱정할 필요 없이 numberOfItems(또는 다른 반응형 값!)를 사용할 수 있다.
- 즉 useEffect와는 별개로 numberOfItems의 값은 조정이 가능하고 url 변경으로 useEffect가 실행되면 최신의 numberOfItems값을 사용할 수 있다.

## 요약

- 이벤트 핸들러는 특정 상호 작용에 대한 응답으로 실행됩니다.
- Effect는 동기화가 필요할 때마다 실행됩니다.
- 이벤트 핸들러 내부의 로직은 반응형이 아닙니다.
- Effect 내부의 로직은 반응적입니다.
- 비반응적 로직을 Effect에서 Effect Event로 이동할 수 있습니다.
- Effect 내부에서만 Effect Event를 호출하세요.
- Effect Event를 다른 컴포넌트나 Hook에 전달하지 마세요.

</br>

# Effect 의존성 제거하기

불필요한 의존성으로 인해 Effect가 자주 실행되거나 무한 루프를 생성할 수 도 있다.  
이번 학습으로 Effect의 불필요한 의존성을 검토하고 제거하자.

## 의존성은 코드와 일치해야 한다.

- Effect에서 사용된 반응형 값은 의존성 배열에 반드시 포함되어야 한다.
- 의존성을 제거하려면 반응형 값에 의존하지 않도록 한다.

> 의존성을 변경하려면 먼저 코드를 변경하고 그에 맞게 의존성을 조정해야한다.

## 불필요한 의존성 제거하기

의존성을 조정하다보면 의존성 중 하나라도 변경되면 꼭 Effect가 실행되어야 하는 것은 아니다.

- 다른 조건에서 Effect의 다른 부분을 다시 실행하고 싶을 수 있다.
- 일부 의존성의 변경에 `반응` 하지 않고 `최신 값`만 읽고 싶을 수 있다.
- 의존성은 객체나 함수이기 때문에 `의도치 않게`너무 자주 변경될 수 있다.

나라, 도시를 선택하는 form 코드를 예제로 살펴보자

```jsx
function ShippingForm({ country }) {
  const [cities, setCities] = useState(null);
  const [city, setCity] = useState(null);

  useEffect(() => {
    let ignore = false;
    fetch(`/api/cities?country=${country}`)
      .then(response => response.json())
      .then(json => {
        if (!ignore) {
          setCities(json);
        }
      });
    return () => {
      ignore = true;
    };
  }, [country]); // ✅ All dependencies declared
```

- 위 예제에서 Effect는 country가 변경되면 새로운 도시들을 동기화한다.
- 이벤트 핸들러로 수행되는 작업이 아닌 ShippingForm이 표시되면서 동기화가 이루어지는 좋은 Effect의 사용이다.

```jsx
function ShippingForm({ country }) {
  const [cities, setCities] = useState(null);
  const [city, setCity] = useState(null);
  const [areas, setAreas] = useState(null);

  useEffect(() => {
    let ignore = false;
    fetch(`/api/cities?country=${country}`)
      .then(response => response.json())
      .then(json => {
        if (!ignore) {
          setCities(json);
        }
      });
    // 🔴 Avoid: A single Effect synchronizes two independent processes
    if (city) {
      fetch(`/api/areas?city=${city}`)
        .then(response => response.json())
        .then(json => {
          if (!ignore) {
            setAreas(json);
          }
        });
    }
    return () => {
      ignore = true;
    };
  }, [country, city]);
```

- 두 번째 선택박스에서 선택된 areas를 패치한다.
- 두 의존성이 함께 Effect에 존재한다면 이미 선택된 나라를 패치하고 도시를 패치한다.
- 이는 불필요한 패치를 여러번 실행하게 된다.

> 서로 관련이 없는 두 가지를 동기화 한다면 불필요한 렌더링이 추가된다.

```jsx
function ShippingForm({ country }) {
  const [cities, setCities] = useState(null);
  useEffect(() => {
    let ignore = false;
    fetch(`/api/cities?country=${country}`)
      .then(response => response.json())
      .then(json => {
        if (!ignore) {
          setCities(json);
        }
      });
    return () => {
      ignore = true;
    };
  }, [country]); // ✅ All dependencies declared

  const [city, setCity] = useState(null);
  const [areas, setAreas] = useState(null);
  useEffect(() => {
    if (city) {
      let ignore = false;
      fetch(`/api/areas?city=${city}`)
        .then(response => response.json())
        .then(json => {
          if (!ignore) {
            setAreas(json);
          }
        });
      return () => {
        ignore = true;
      };
    }
  }, [city]); // ✅ All dependencies declared
```

- 독립적인 프로세스는 각각의 Effect로 구분되어야 한다.
- 분할로 인해 불필요한 렌더링을 줄일 수 있다.

> 반복되는 로직은 커스텀 Hook으로 추출할 수 있다.

## 의존성 배열에 `객체`, `배열` 사용하지 않기

반응형 값으로 `객체`, `배열`을 사용한 경우 변경된 값이 없어도 Effect가 실행될 수 있다.

```jsx
import { useState, useEffect } from "react";
import { createConnection } from "./chat.js";

const serverUrl = "https://localhost:1234";

function ChatRoom({ roomId }) {
  const [message, setMessage] = useState("");

  // Temporarily disable the linter to demonstrate the problem
  // eslint-disable-next-line react-hooks/exhaustive-deps
  const options = {
    serverUrl: serverUrl,
    roomId: roomId,
  };

  useEffect(() => {
    const connection = createConnection(options);
    connection.connect();
    return () => connection.disconnect();
  }, [options]);

  return (
    <>
      <h1>Welcome to the {roomId} room!</h1>
      <input value={message} onChange={(e) => setMessage(e.target.value)} />
    </>
  );
}

export default function App() {
  const [roomId, setRoomId] = useState("general");
  return (
    <>
      <label>
        Choose the chat room:{" "}
        <select value={roomId} onChange={(e) => setRoomId(e.target.value)}>
          <option value="general">general</option>
          <option value="travel">travel</option>
          <option value="music">music</option>
        </select>
      </label>
      <hr />
      <ChatRoom roomId={roomId} />
    </>
  );
}
```

- 위 예제에서 roomId가 변경되면 options가 변경되고 Effect가 일어난다(연결).
- 문제는 의존성 배열로 options 객체가 사용되었다.
- **setMessage로 메시지가 변경되어도 Effect가 실행된다.**

> JavaScript에서는 새로 생성된 객체는 값이 동일해도 다른 객체로 간주한다.

- 이는 roomId가 변경되지 않아도 자바스크립트는 새로운 객체(options)로 판단하고 Effect를 실행한다.

### 객체에서 원시 값 읽기

```jsx
function ChatRoom({ options }) {
  const [message, setMessage] = useState('');

  const { roomId, serverUrl } = options;
  useEffect(() => {
    const connection = createConnection({
      roomId: roomId,
      serverUrl: serverUrl
    });
    connection.connect();
    return () => connection.disconnect();
  }, [roomId, serverUrl]); // ✅ All dependencies declared
  // ...
```

- 위 문제를 해결하기 위해 Effect 외부의 객체에서 정보를 읽어서 객체 의존성을 피해야한다.
- Effect 외부의 객체에서 일부 값을 읽고 Effect 내부에 동일한 값을 가진 객체를 만든다.
- 이 경우 Effect가 어떤 정보에 의존하는지 명확하게 알 수 있다.

## 요약

- 의존성은 항상 코드와 일치해야 합니다.
- 의존성이 마음에 들지 않으면 코드를 수정해야 합니다.
- 린터를 억제하면 매우 혼란스러운 버그가 발생하므로 항상 피해야 합니다.
- 의존성을 제거하려면 해당 의존성이 필요하지 않다는 것을 린터에게 “증명”해야 합니다.
- 특정 상호작용에 대한 응답으로 일부 코드가 실행되어야 하는 경우 해당 코드를 이벤트 핸들러로 이동하세요.
- Effect의 다른 부분이 다른 이유로 다시 실행되어야 하는 경우 여러 개의 Effect로 분할하세요.
- 이전 state를 기반으로 일부 state를 업데이트하려면 업데이터 함수를 전달하세요.
- “반응”하지 않고 최신 값을 읽으려면 Effect에서 Effect Event를 추출하세요.
- JavaScript에서 객체와 함수는 서로 다른 시간에 생성된 경우 서로 다른 것으로 간주됩니다.
- 객체와 함수의 의존성을 피하세요. 컴포넌트 외부나 Effect 내부로 이동하세요.
