# 탈출구

컴포넌트 중 일부는 React 외부의 시스템을 제어하고 동기화해야 할 수 있다.

- 브라우저 API를 사용해 input에 초점을 맞추는 경우
- React 없이 구현된 비디오 플레이어를 재생 및 일시정지하는 경우
- 원격 서버에 연결해서 메시지를 수신해야 할 경우

> React의 `외부`로 나가서 외부 시스템에 연결할 수 있는 탈출구에 대해 알아보자.

## 이 챕터에서 다룰 내용

- 리렌더링하지 않고 정보를 “기억”하는 방법
- React가 관리하는 DOM 엘리먼트에 접근하는 방법
- 컴포넌트를 외부 시스템과 동기화하는 방법
- 컴포넌트에서 불필요한 Effect를 제거하는 방법
- effect의 생명주기가 컴포넌트와 어떻게 다른지
- 일부 값이 Effect를 다시 촉발하는 것을 방지하는 방법
- Effect 재실행 빈도를 줄이는 방법
- 컴포넌트 간 로직을 공유하는 방법

</br>

# ref로 값 참조하기

- 컴포넌트가 특정 정보를 `기억` 하도록 하고 싶지만 해당 정고가 `새 렌더링을 촉발하지 않도록` 하려는 경우 ref를 사용할 수 있다.

## 컴포넌트에 ref 추가하기

1. useRef 훅을 가져온다.

```jsx
import { useRef } from "react";
```

2. useRef 혹을 호출하고 참조할 초기밧을 인자로 전달한다.

```jsx
const ref = useRef(0);
```

3. useRef는 다음과 같은 객체를 반환한다.

```json
{
  "current": 0 // The value you passed to useRef
}
```

- ref.current 속성을 통해 해당 ref의 현재 값에 엑세스할 수 있다.
- 이 값은 읽기와 쓰기가 모두 가능하다.

```jsx
import { useRef } from "react";

export default function Counter() {
  let ref = useRef(0);

  function handleClick() {
    ref.current = ref.current + 1;
    alert("You clicked " + ref.current + " times!");
  }

  return <button onClick={handleClick}>Click me!</button>;
}
```

> `ref`는 React가 추적하지 않는 컴포넌트의 `비밀 주머니`와 같다.

- ref는 숫자 뿐만이 아닌 state와 마찬가지로 문자열, 객체, 함수 등 무엇이든 가리킬 수 있다.
- ref는 current 속성을 읽고 수정할 수 있는 일반 JavaScript 객체다.
- **ref는 state와 마찬가지로 값을 유지하면서 state와는 다르게 컴포넌트가 리렌더링되지 않는다.**

## state와 ref 함께 사용하기 (스톱워치)

```jsx
import { useState, useRef } from "react";

export default function Stopwatch() {
  // 컴포넌트가 새로운 값으로 렌더링 되어야하는 시간은 state로 관리한다.
  const [startTime, setStartTime] = useState(null);
  const [now, setNow] = useState(null);

  // 컴포넌트 렌더링과는 상관 없지만 기억해야하는 interval ID는 ref로 관리한다.
  const intervalRef = useRef(null);

  function handleStart() {
    setStartTime(Date.now());
    setNow(Date.now());

    // setInterval이 호출한 interval ID를 clearInterval()에 제공
    clearInterval(intervalRef.current);
    intervalRef.current = setInterval(() => {
      setNow(Date.now());
    }, 10);
  }

  function handleStop() {
    // setInterval이 호출한 interval ID를 clearInterval()에 제공
    clearInterval(intervalRef.current);
  }

  let secondsPassed = 0;
  if (startTime != null && now != null) {
    secondsPassed = (now - startTime) / 1000;
  }

  return (
    <>
      <h1>Time passed: {secondsPassed.toFixed(3)}</h1>
      <button onClick={handleStart}>Start</button>
      <button onClick={handleStop}>Stop</button>
    </>
  );
}
```

- 렌더링에 정보가 사용되는 경우 해당 정보를 state로 유지한다.
- 이벤트 핸들러만 정보를 필요로 하고 변경해도 다시 렌더링할 필요가 없는 경우 ref를 사용한다.

## ref와 state의 차이점

| refs                                                                       | state                                                                                         |
| -------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------- |
| useRef(initialValue)는 { current: initialValue }을 반환                    | useState(initialValue)는 state 변수의 현재값과 state 설정자함수([value, setValue])를 반환     |
| 변경 시 리렌더링을 촉발하지 않음                                           | 변경 시 리렌더링을 촉발함                                                                     |
| Mutable— 렌더링 프로세스 외부에서 current 값을 수정하고 업데이트할 수 있음 | “Immutable”— state setting 함수를 사용하여 state 변수를 수정해 리렌더링을 대기열에 추가해야함 |
| 렌더링 중에는 current 값을 읽거나 쓰지 않아야 함                           | 언제든지 state를 읽을 수 있음. 각 렌더링에는 변경되지 않는 자체 state snapshot이 있음         |

## ref는 설정자가 없는 일반 state 변수라고 생각하면 된다.

```jsx
// Inside of React
function useRef(initialValue) {
  const [ref, unused] = useState({ current: initialValue });
  return ref;
}
```

## ref를 사용해야 하는 경우

ref는 컴포넌트가 React로부터 `외부로 나가서` 외부 API, 즉 컴포넌트의 형상에 영향을 주지 않는 브라우저 API 등과 통신해야 할 때 사용된다.

- timeout ID 저장
- 다음 페이지에서 다룰 DOM elements 저장 및 조작
- JSX를 계산하는 데 필요하지 않은 다른 객체 저장

> 컴포넌트에 일부 값을 저장해야 하지만 렌더링 로직에는 영향을 미치지 않는 경우에 사용한다.

## ref 모범 사례

- ref를 탈출구(외부 시스템, API 작업)로 취급하자.
- 애플리케이션 로직과 데이터 흐름에는 사용을 조심하자.
- 렌더링 중에는 ref.current를 읽거나 쓰지 말자.(첫 번째 렌더링에만 사용)
- ❓렌더링 중이라는 것은 첫 마운트 제외하고 리랜더링의 경우를 말하는 건가?

> state는 모든 렌더링에서 스냅샷처럼 작동하며 동기적으로 업데이트 되지 않지만 ref는 값을 변경하는 즉시 변경된다.

</br>

# ref로 DOM 조작하기

- React는 렌더링 출력과 일치하도록 DOM을 자동으로 업데이트 해준다.
- 하지만 노드에 초점을 맞추거나 스크롤하거나 크기와 위치를 측정하기 위해 React가 관리하는 DOM요소에 접근해야 할 수도 있다.
- DOM노드에 대한 ref를 만들어서 접근한다.

## 노드에 대한 ref 가져오기

1. useRef 훅을 불러온다.

```jsx
import { useRef } from "react";
```

2. 컴포넌트 내부에서 ref를 선언한다.

```jsx
const myRef = useRef(null);
```

3. **DOM 노드를 가져올 JSX 태그에 ref 속성으로 참조를 전달한다.**

```jsx
<div ref={myRef}>
```

- useRef 훅은 current라고 하는 프로퍼티가 포함된 객체를 반환한다.
- 처음 myRef.current는 null을 가진다.
- React가 `<div>`에 대한 DOM 노드를 생성하면, useRef.current에 노드가 들어간다.
- 노드를 가진 useRef.current는 빌트인 브라우서 API 사용이 가능하다.

```jsx
// 모든 브라우저 API를 사용할 수 있다. 예를 들어:
myRef.current.scrollIntoView();
```

## 텍스트 input에 초점 맞추기

```jsx
import { useRef } from "react";

export default function Form() {
  const inputRef = useRef(null);

  function handleClick() {
    inputRef.current.focus();
  }

  return (
    <>
      // 노드에 ref 전달
      <input ref={inputRef} />
      <button onClick={handleClick}>Focus the input</button>
    </>
  );
}
```

- `<input ref={inputRef} />` input의 DOM 노드를 `inputRef.current`에 넣는다.
- handleClick 함수에서 inputRef.current로부터 `input DOM 노드를 읽어`와서 inputRef.current.focus()로 `focus()를 호출`합니다.

## ref 콜백을 사용하여 refs 목록을 관리하는 방법

필요한 DOM 노드를 ref로 만들어서 사용해봤다.  
하지만, 한 목록의 모든 요소를 사용한다면 어떻게 될까?  
**얼마나 많은 ref가 필요한지 알 수 없는 경우의 방법을 알아보자**

- ref 속성에 함수를 전달해준다. 이를 `ref 콜백`이라고 한다.
- React는 ref를 설정할 떄가 되면 DOM 노드로, 지울 때가 되면 null로 ref 콜백을 호출한다.
- 이를 통해 자신만의 배열(인덱스)이나 Map(ID)로 모든 ref에 접근할 수 있다.

```jsx
import { useRef } from "react";

export default function CatFriends() {
  const itemsRef = useRef(null);

  function scrollToId(itemId) {
    const map = getMap(); // map으로 저장된 itemsRef 가져오기
    const node = map.get(itemId); // map안에서 선택된 id로 node 가져오기
    node.scrollIntoView({
      behavior: "smooth",
      block: "nearest",
      inline: "center",
    });
  }

  function getMap() {
    if (!itemsRef.current) {
      // Initialize the Map on first usage.
      itemsRef.current = new Map();
    }
    return itemsRef.current;
  }

  return (
    <>
      <nav>
        <button onClick={() => scrollToId(0)}>Tom</button>
        <button onClick={() => scrollToId(5)}>Maru</button>
        <button onClick={() => scrollToId(9)}>Jellylorum</button>
      </nav>
      <div>
        <ul>
          {catList.map((cat) => (
            <li
              key={cat.id}
              ref={(node) => {
                const map = getMap();
                if (node) {
                  map.set(cat.id, node);
                } else {
                  map.delete(cat.id);
                }
              }}
            >
              <img src={cat.imageUrl} alt={"Cat #" + cat.id} />
            </li>
          ))}
        </ul>
      </div>
    </>
  );
}

const catList = [];
for (let i = 0; i < 10; i++) {
  catList.push({
    id: i,
    imageUrl: "https://placekitten.com/250/200?image=" + i,
  });
}
```

- 위 예제에서 itemsRef는 하나만의 DOM 노드를 보유하지 않는다.
- DOM 노드들이 모여있는 Map을 보유한다.

```jsx
<li
  key={cat.id}
  ref={node => {
    const map = getMap();
    if (node) {
      // Add to the Map
      map.set(cat.id, node);
    } else {
      // Remove from the Map
      map.delete(cat.id);
    }
  }}
>
```

- catList에서 노드를 만들때 ref map도 업데이트 된다.

## 다른 컴포넌트의 DOM 노드에 접근하기

- 위 예제들에서는 빌트인 컴포넌트 `<input>`, `li` 등에 ref를 주었다.
- 하지만 만들어진 컴포넌트(함수 컴포넌트)에 ref를 넣으면 기본적으로 null이 반환된다.

```jsx
import { useRef } from "react";

// 만들어진 input을 반환하는 함수 컴포넌트
function MyInput(props) {
  return <input {...props} />;
}

export default function MyForm() {
  const inputRef = useRef(null);

  function handleClick() {
    inputRef.current.focus();
  }

  return (
    <>
      <MyInput ref={inputRef} />
      <button onClick={handleClick}>Focus the input</button>
    </>
  );
}
```

```
Warning: Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?
// 경고: 함수 컴포넌트에는 refs를 지정할 수 없습니다. 이 ref에 접근하려는 시도는 실패합니다. React.forwardRef()를 사용하려고 하셨나요?
```

> 기본적으로 React는 한 컴포넌트가 다른 컴포넌트의 DOM 노드에 접근하는 것을 차단하기 때문이다.

- 해결방법으로는 DOM 노드를 다른 컴포넌트가 사용할 수 있도록 설정해야한다.
- 이는 상위 컴포넌트로부터 ref를 전달 받을 수 있도록 하는 것이다.

```jsx
const MyInput = forwardRef((props, ref) => {
  return <input {...props} ref={ref} />;
});
```

- MyInput 컴포넌트를 `forwardRef`를 사용하여 선언하면, props 다음의 두 번째 `ref 인수`에 상위 컴포넌트의 `inputRef`를 받도록 설정한다.
- MyInput은 수신한 ref를 내부의 `<input>`으로 전달한다.

```jsx
import { forwardRef, useRef } from "react";

const MyInput = forwardRef((props, ref) => {
  return <input {...props} ref={ref} />;
});

export default function Form() {
  const inputRef = useRef(null);

  function handleClick() {
    inputRef.current.focus();
  }

  return (
    <>
      <MyInput ref={inputRef} />
      <button onClick={handleClick}>Focus the input</button>
    </>
  );
}
```

> 위와 같은 방식은 버튼, 입력 등과 같은 저수준 컴포넌트에서만 사용하는 것이 좋다.

## DOM 노트 노출을 제한하기

위 예제에서 MyInput은 DOM input 엘리먼트를 노출하고 있다.  
만약 focus()만을 위해서 노출을 하도록 만들고 싶다면 `useImperativeHandle`를 사용할 수 있다.

```jsx
import { forwardRef, useRef, useImperativeHandle } from "react";

const MyInput = forwardRef((props, ref) => {
  const realInputRef = useRef(null);
  useImperativeHandle(ref, () => ({
    // Only expose focus and nothing else
    focus() {
      realInputRef.current.focus();
    },
  }));
  return <input {...props} ref={realInputRef} />;
});

export default function Form() {
  const inputRef = useRef(null);

  function handleClick() {
    inputRef.current.focus();
  }

  return (
    <>
      <MyInput ref={inputRef} />
      <button onClick={handleClick}>Focus the input</button>
    </>
  );
}
```

## React가 ref를 첨부할 때

React에서 모든 업데이트는 두 단계로 나뉜다.

- 렌더링 : React는 컴포넌트를 호출하여 화면에 무엇이 표시되어야 하는지 파악한다.
  - 렌더링 중에는 DOM 노드가 아직 생성되지 않았으므로 ref.current는 null이다.
- 커밋 : React는 DOM에 변경 사항을 적용한다.
  - 커밋 단계에서 ref.current를 설정한다.
  - DOM이 업데이트된 직후 해당 DOM 노드를 다시 설정한다.

## state를 동기식으로 업데이트하기

아래 예제에서 todo 목록이 추가되면 추가된 노드로 스크롤이 이동되게 하고자 한다.

```jsx
import { useState, useRef } from "react";

export default function TodoList() {
  const listRef = useRef(null);
  const [text, setText] = useState("");
  const [todos, setTodos] = useState(initialTodos);

  function handleAdd() {
    const newTodo = { id: nextId++, text: text };
    setText("");
    setTodos([...todos, newTodo]);
    listRef.current.lastChild.scrollIntoView({
      behavior: "smooth",
      block: "nearest",
    });
  }

  return (
    <>
      <button onClick={handleAdd}>Add</button>
      <input value={text} onChange={(e) => setText(e.target.value)} />
      <ul ref={listRef}>
        {todos.map((todo) => (
          <li key={todo.id}>{todo.text}</li>
        ))}
      </ul>
    </>
  );
}

let nextId = 0;
let initialTodos = [];
for (let i = 0; i < 20; i++) {
  initialTodos.push({
    id: nextId++,
    text: "Todo #" + (i + 1),
  });
}
```

- 결과는 추가된 노드위치가 아닌 그 이전 상태의 마지막 노드로 이동된다.
- state는 DOM을 즉시 업데이트 하지 않기 때문이다.

```jsx
setTodos([...todos, newTodo]);
listRef.current.lastChild.scrollIntoView();
```

- setTodos는 업데이트 된 후 재렌더링으로 노드를 추가한다.
- scrollIntoView()는 업데이트 단계에서 진행이 되버린다.
- **`flushSync`로 state 업데이트를 동기적으로 만들 수 있다.**

```jsx
import { useState, useRef } from "react";
import { flushSync } from "react-dom";

export default function TodoList() {
  const listRef = useRef(null);
  const [text, setText] = useState("");
  const [todos, setTodos] = useState(initialTodos);

  function handleAdd() {
    const newTodo = { id: nextId++, text: text };
    flushSync(() => {
      setText("");
      setTodos([...todos, newTodo]);
    });
    listRef.current.lastChild.scrollIntoView({
      behavior: "smooth",
      block: "nearest",
    });
  }

  return (
    <>
      <button onClick={handleAdd}>Add</button>
      <input value={text} onChange={(e) => setText(e.target.value)} />
      <ul ref={listRef}>
        {todos.map((todo) => (
          <li key={todo.id}>{todo.text}</li>
        ))}
      </ul>
    </>
  );
}

let nextId = 0;
let initialTodos = [];
for (let i = 0; i < 20; i++) {
  initialTodos.push({
    id: nextId++,
    text: "Todo #" + (i + 1),
  });
}
```

## ref를 이용한 DOM 조작 모범 사례

- React가 관리하는 DOM 노드를 변경하면 안된다.
- React가 업데이트할 이유가 없는 DOM의 일부는 안전하게 수정할 수 있다.

</br>

# Effect와 동기화 하기

일부 컴포넌트는 외부 시스템과 동기화해야 한다.

- React state를 기반으로 React가 아닌 컴포넌트를 제어할떄
- 서버 연결을 설정할때
- 컴포넌트가 화면에 나타날 때 분석 로그를 보낼때

> Effect를 사용하면 렌더링 이후 일부 코드를 실행할 수 있으며 외부 시스템과 동기화할 수 있다.

## Effect란 무엇이며 이벤트와는 어떤게 다른가

React는 두가지 작업 유형이 존재한다.

- 렌더링 : props와 state를 가져와 JSX를 반환
- 이벤트 핸들러 : 사용자 작업으로 발생하는 사이드 이펙트

> Effect는 사용자 이벤트가 아닌 렌더링 자체로 인해 발생하는 사이드 이펙트를 명시할 수 있다.  
> ex. 서버 연걸

## Effect가 필요하지 않을 수도 있다.

Effect는 일반적으로 React 코드에서 벗어나 외부 시스템과 동기화하는데 사용된다.  
Effect가 아닌 다른 state를 기반으로 일부 state만을 조정하는 경우, Effect가 필요하지 않을 수도 있다.

## Effect 작성방법

### 1. Effect 선언

```jsx
import { useEffect } from "react";

function MyComponent() {
  useEffect(() => {
    // Code here will run after *every* render
    // 여기의 코드는 매 렌더링 후에 실행됩니다.
  });
  return <div />;
}
```

- 컴포넌트가 렌더링될 때마다 React는 화면을 업데이트하고 useEffect 내부의 코드를 실행한다.
- 즉, useEffect는 해당 렌더링이 화면에 반영이 될 때까지 코드 조각의 실행을 “지연”한다.

```jsx
import { useState, useRef, useEffect } from "react";

function VideoPlayer({ src, isPlaying }) {
  const ref = useRef(null);

  useEffect(() => {
    if (isPlaying) {
      ref.current.play();
    } else {
      ref.current.pause();
    }
  });

  return <video ref={ref} src={src} loop playsInline />;
}

export default function App() {
  const [isPlaying, setIsPlaying] = useState(false);
  return (
    <>
      <button onClick={() => setIsPlaying(!isPlaying)}>
        {isPlaying ? "Pause" : "Play"}
      </button>
      <VideoPlayer
        isPlaying={isPlaying}
        src="https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4"
      />
    </>
  );
}
```

- VideoPlayer는 App으로 부터 재생여부 props를 전달받는다.
- Effect 없이 전달받은 props isPlaying으로 동영상을 컨트롤하려고 하면 문제가 발생한다.
- 아직 VideoPlayer의 모든 DOM이 렌더링되지 않았는데, 재생 여부를 묻기 때문이다.

```jsx
if (isPlaying) {
  ref.current.play(); // Calling these while rendering isn't allowed.
} else {
  ref.current.pause(); // Also, this crashes.
}
```

> useEffect는 모든 렌더링이 일어난 후에 발생하기에 이러한 문제를 해결해준다.

### 2. Effect 의존성 지정하기

- 기본적으로 Effect는 `매번` 렌더링 후에 실행된다.
- 특정한 경우에만 Effect가 일어나게 하기위해서는 의존성을 지정해야 한다.

```jsx
useEffect(() => {
  // This runs after every render
  // 렌더시마다 실행됩니다.
});

useEffect(() => {
  // This runs only on mount (when the component appears)
  // 오직 마운트시(컴포넌트가 나타날 때)에만 실행됩니다.
}, []);

useEffect(() => {
  // This runs on mount *and also* if either a or b have changed since the last render
  // 마운트시 뿐만 아니라 a 또는 b가 직전 렌더와 달라졌을 때에도 실행됩니다.
}, [a, b]);
```

- 의존성 배열은 여러 개의 의존성을 포함할 수 있다.

### 3. 필요한 경우 클린업을 추가한다.

채팅 서버에 연결해야 한느 ChatRoom 컴포넌트를 생각해보자.

```jsx
import { useEffect } from "react";
import { createConnection } from "./chat.js";

export default function ChatRoom() {
  useEffect(() => {
    const connection = createConnection();
    connection.connect();
  }, []);
  return <h1>Welcome to the chat!</h1>;
}

export function createConnection() {
  // A real implementation would actually connect to the server
  return {
    connect() {
      console.log("✅ Connecting...");
    },
    disconnect() {
      console.log("❌ Disconnected.");
    },
  };
}
```

- 마운트때 서버를 연결한다.
- **여기서 문제는 마운트 마다 서버에 연결한다는 것이다.**
- 언마운트시 없에야 하는 코드를 추가해야한다.

```jsx
export default function ChatRoom() {
  useEffect(() => {
    const connection = createConnection();
    connection.connect();
    return () => connection.disconnect();
  }, []);
```

> **💡 useEffect에서 반환하는 함수는 컴포넌트가 언마운트될 때 호출되는 클린업 함수다.**
>
> - 이벤트 리스너 제거
> - 네트워크 요청 취소
> - 타이머 해체

❓ 로그인 엄격모드 문제 이걸로....?

## 개발 환경에서 두 번씩 실행되는 Effect를 처리하는 방법은 무엇일까?

- React는 개발 환경에서 버그를 찾기 위해 컴포넌트를 의도적으로 다시 다운트 한다.
- 어떻게 하면 Effect를 한 번만 실행할 수 있는가? 가 아닌
- **어떻게 다시 마운트한 후에도 Effect가 잘 작동하도록 수정하는가?** 이다.

> 클린업 함수를 구현하는 것이다. 클린업 함수는 Effect가 수행 중이던 작업을 중지하거나 취소해야 한다.

### React가 아닌 위젯 제어하기

- 지도와 같은 UI 위젯은 React로 작성하지 않은 경우다.
- 지도의 확대/축소를 state 변수와 동기화한다.

```jsx
useEffect(() => {
  const map = mapRef.current;
  map.setZoomLevel(zoomLevel);
}, [zoomLevel]);
```

- 이 경우에는 클린업이 필요하지 않다.
- 두번 호출해도 아무러 문제가 없기 때문이다.
- 더욱이 상용 환경에서는 불필요하게 다시 마운트 되지 않는다.

아래의 경우는 두 번 연속으로 호출하면 안된다.

```jsx
useEffect(() => {
  const dialog = dialogRef.current;
  dialog.showModal();
  return () => dialog.close();
}, []);
```

- 브라우저 빌트인 요소인 `<dialog>`는 `showModal()`를 두번 호출하면 에어가 발생한다.
- 개발 중에 Effect는 showModal()을 호출한 다음 즉시 close()를 호출하고, 다시 showModal()을 호출한다.
- 이는 상용 환경에서 볼 수 있는 것처럼 showModal()을 한 번 호출하는 것과 체감상 동일하다.

### 이벤트 구독하기

- Effect가 무언가를 구독하는 경우, 클린업 함수는 구독을 취소해야 한다.

```jsx
useEffect(() => {
  function handleScroll(e) {
    console.log(window.scrollX, window.scrollY);
  }
  window.addEventListener("scroll", handleScroll);
  return () => window.removeEventListener("scroll", handleScroll);
}, []);
```

- 개발 중에 Effect는 addEventListener()를 호출한 다음 즉시 removeEventListener()를 호출한다. - 그런 다음 동일한 핸들러를 사용하여 다시 addEventListener()를 사용함으로써, 한 번에 하나의 구독만 활성화 되도록 한다.
- 이는 상용 환경에서 addEventListener()를 한 번만 호출하는 것과 체감상 동일한다.

### 애니메이션 촉발하기

- Effect가 무언가를 애니메이션하는 경우 클린업 함수는 애니메이션을 초기값으로 재설정해야 한다.

```jsx
useEffect(() => {
  const node = ref.current;
  node.style.opacity = 1; // Trigger the animation
  // 애니메이션 촉발
  return () => {
    node.style.opacity = 0; // Reset to the initial value
    // 초기값으로 재설정
  };
}, []);
```

- 만약 트위닝을 지원하는 서드파티 애니메이션 라이브러리를 사용하는 경우라면, 클린업 함수에서 타임라인을 초기 state로 재설정해줘야 한다.

### 데이터 페칭하기

- Effect가 무언가를 페치하면 클린업 함수는 페치를 중단하거나 그 결과를 무시해야 한다.

```jsx
useEffect(() => {
  let ignore = false;

  async function startFetching() {
    const json = await fetchTodos(userId);
    if (!ignore) {
      setTodos(json);
    }
  }

  startFetching();

  return () => {
    ignore = true;
  };
}, [userId]);
```

- 이미 발생한 네트워크 요청을 "실행 취소" 할 수는 없다.
- 클린업 함수에서 더 이상 `관련이 없는 페치`가 애플리케이션에 계속 영향을 미치지 않도록 해야한다.
- userId가 'Alice'에서 'Bob'으로 변경되면 클린업은 'Alice' 응답이 'Bob' 이후에 도착하더라도 이를 무시하도록 한다.

> 상용 환경에서는 요청이 하나만 있다. 개발 중인 두 번째 요청이 귀찮은 경우 가장 좋은 방법은 요청을 중복 제거하고 컴포넌트 간에 응답을 `캐시하는 솔루션`을 사용하는 것이다.

### 분석 보내기

```jsx
useEffect(() => {
  logVisit(url); // Sends a POST request
}, [url]);
```

### Effect가 아닌 경우 : 애플리케이션 초기화하기

- 일부 로직은 애플리케이션이 시작될 때 한 번만 실행되어야 한다.
- 이런 로직은 컴포넌트 외부에 넣을 수 있다.

```jsx
if (typeof window !== "undefined") {
  // Check if we're running in the browser.
  // 실행환경이 브라우저인지 여부 확인
  checkAuthToken();
  loadDataFromLocalStorage();
}

function App() {
  // ...
}
```

### Effect가 아닌 경우 : 제품 구매하기

```jsx
useEffect(() => {
  // 🔴 Wrong: This Effect fires twice in development, exposing a problem in the code.
  // 🔴 틀렸습니다: 이 Effect는 개발모드에서 두 번 실행되며, 문제를 일으킵니다.
  fetch("/api/buy", { method: "POST" });
}, []);
```

- 제품을 두 번 사면 안된다.
- 이 로직은 Effect에서 제거되어야 한다.
- 구매는 렌더링으로 인한 것이 아니다. `특정 상호 작용`으로 인해 발생한다.

```jsx
function handleClick() {
  // ✅ Buying is an event because it is caused by a particular interaction.
  // ✅ 구매는 특정 상호작용으로 인해 발생하므로 이벤트입니다.
  fetch("/api/buy", { method: "POST" });
}
```

## 요약

- 이벤트와 달리 Effect는 특정 상호 작용이 아닌 렌더링 자체에 의해 발생합니다.
- Effect를 사용하면 일부 외부 시스템(서드파티 API, 네트워크 등)과 컴포넌트를 동기화할 수 있습니다.
- 기본적으로 Effect는 모든 렌더링 후에 실행됩니다(초기 렌더링 포함).
- React는 모든 의존성이 마지막 렌더링 시점과 동일한 값을 갖는 경우 Effect를 건너뜁니다.
- 의존성을 “선택”할 수는 없습니다. 그들은 Effect 내부의 코드에 의해 결정됩니다.
- 빈 의존성 배열([])은 컴포넌트 “마운팅”, 즉,화면에 추가되는 시점에 대응합니다.
- Strict 모드에서 React는 컴포넌트를 두 번 마운트하여(개발 중인 경우에만!) Effect를 스트레스 테스트합니다.
- 다시 마운트를 수행함으로 인해 Effect가 깨지는 경우, 클린업 함수를 구현해야 합니다.
- React는 다음 Effect가 실행되기 전 및 마운트 해제 시점에 클린업 함수를 호출합니다.
