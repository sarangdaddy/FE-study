# 탈출구

컴포넌트 중 일부는 React 외부의 시스템을 제어하고 동기화해야 할 수 있다.

- 브라우저 API를 사용해 input에 초점을 맞추는 경우
- React 없이 구현된 비디오 플레이어를 재생 및 일시정지하는 경우
- 원격 서버에 연결해서 메시지를 수신해야 할 경우

> React의 `외부`로 나가서 외부 시스템에 연결할 수 있는 탈출구에 대해 알아보자.

# 이 챕터에서 다룰 내용

- 리렌더링하지 않고 정보를 “기억”하는 방법
- React가 관리하는 DOM 엘리먼트에 접근하는 방법
- 컴포넌트를 외부 시스템과 동기화하는 방법
- 컴포넌트에서 불필요한 Effect를 제거하는 방법
- effect의 생명주기가 컴포넌트와 어떻게 다른지
- 일부 값이 Effect를 다시 촉발하는 것을 방지하는 방법
- Effect 재실행 빈도를 줄이는 방법
- 컴포넌트 간 로직을 공유하는 방법

# ref로 값 참조하기

- 컴포넌트가 특정 정보를 `기억` 하도록 하고 싶지만 해당 정고가 `새 렌더링을 촉발하지 않도록` 하려는 경우 ref를 사용할 수 있다.

## 컴포넌트에 ref 추가하기

1. useRef 훅을 가져온다.

```jsx
import { useRef } from "react";
```

2. useRef 혹을 호출하고 참조할 초기밧을 인자로 전달한다.

```jsx
const ref = useRef(0);
```

3. useRef는 다음과 같은 객체를 반환한다.

```json
{
  "current": 0 // The value you passed to useRef
}
```

- ref.current 속성을 통해 해당 ref의 현재 값에 엑세스할 수 있다.
- 이 값은 읽기와 쓰기가 모두 가능하다.

```jsx
import { useRef } from "react";

export default function Counter() {
  let ref = useRef(0);

  function handleClick() {
    ref.current = ref.current + 1;
    alert("You clicked " + ref.current + " times!");
  }

  return <button onClick={handleClick}>Click me!</button>;
}
```

> `ref`는 React가 추적하지 않는 컴포넌트의 `비밀 주머니`와 같다.

- ref는 숫자 뿐만이 아닌 state와 마찬가지로 문자열, 객체, 함수 등 무엇이든 가리킬 수 있다.
- ref는 current 속성을 읽고 수정할 수 있는 일반 JavaScript 객체다.
- **ref는 state와 마찬가지로 값을 유지하면서 state와는 다르게 컴포넌트가 리렌더링되지 않는다.**

## state와 ref 함께 사용하기 (스톱워치)

```jsx
import { useState, useRef } from "react";

export default function Stopwatch() {
  // 컴포넌트가 새로운 값으로 렌더링 되어야하는 시간은 state로 관리한다.
  const [startTime, setStartTime] = useState(null);
  const [now, setNow] = useState(null);

  // 컴포넌트 렌더링과는 상관 없지만 기억해야하는 interval ID는 ref로 관리한다.
  const intervalRef = useRef(null);

  function handleStart() {
    setStartTime(Date.now());
    setNow(Date.now());

    // setInterval이 호출한 interval ID를 clearInterval()에 제공
    clearInterval(intervalRef.current);
    intervalRef.current = setInterval(() => {
      setNow(Date.now());
    }, 10);
  }

  function handleStop() {
    // setInterval이 호출한 interval ID를 clearInterval()에 제공
    clearInterval(intervalRef.current);
  }

  let secondsPassed = 0;
  if (startTime != null && now != null) {
    secondsPassed = (now - startTime) / 1000;
  }

  return (
    <>
      <h1>Time passed: {secondsPassed.toFixed(3)}</h1>
      <button onClick={handleStart}>Start</button>
      <button onClick={handleStop}>Stop</button>
    </>
  );
}
```

- 렌더링에 정보가 사용되는 경우 해당 정보를 state로 유지한다.
- 이벤트 핸들러만 정보를 필요로 하고 변경해도 다시 렌더링할 필요가 없는 경우 ref를 사용한다.

## ref와 state의 차이점

| refs                                                                       | state                                                                                         |
| -------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------- |
| useRef(initialValue)는 { current: initialValue }을 반환                    | useState(initialValue)는 state 변수의 현재값과 state 설정자함수([value, setValue])를 반환     |
| 변경 시 리렌더링을 촉발하지 않음                                           | 변경 시 리렌더링을 촉발함                                                                     |
| Mutable— 렌더링 프로세스 외부에서 current 값을 수정하고 업데이트할 수 있음 | “Immutable”— state setting 함수를 사용하여 state 변수를 수정해 리렌더링을 대기열에 추가해야함 |
| 렌더링 중에는 current 값을 읽거나 쓰지 않아야 함                           | 언제든지 state를 읽을 수 있음. 각 렌더링에는 변경되지 않는 자체 state snapshot이 있음         |

## ref는 설정자가 없는 일반 state 변수라고 생각하면 된다.

```jsx
// Inside of React
function useRef(initialValue) {
  const [ref, unused] = useState({ current: initialValue });
  return ref;
}
```

## ref를 사용해야 하는 경우

ref는 컴포넌트가 React로부터 `외부로 나가서` 외부 API, 즉 컴포넌트의 형상에 영향을 주지 않는 브라우저 API 등과 통신해야 할 때 사용된다.

- timeout ID 저장
- 다음 페이지에서 다룰 DOM elements 저장 및 조작
- JSX를 계산하는 데 필요하지 않은 다른 객체 저장

> 컴포넌트에 일부 값을 저장해야 하지만 렌더링 로직에는 영향을 미치지 않는 경우에 사용한다.

## ref 모범 사례

- ref를 탈출구(외부 시스템, API 작업)로 취급하자.
- 애플리케이션 로직과 데이터 흐름에는 사용을 조심하자.
- 렌더링 중에는 ref.current를 읽거나 쓰지 말자.(첫 번째 렌더링에만 사용)
- ❓렌더링 중이라는 것은 첫 마운트 제외하고 리랜더링의 경우를 말하는 건가?

> state는 모든 렌더링에서 스냅샷처럼 작동하며 동기적으로 업데이트 되지 않지만 ref는 값을 변경하는 즉시 변경된다.
