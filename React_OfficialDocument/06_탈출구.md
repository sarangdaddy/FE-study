# 탈출구

컴포넌트 중 일부는 React 외부의 시스템을 제어하고 동기화해야 할 수 있다.

- 브라우저 API를 사용해 input에 초점을 맞추는 경우
- React 없이 구현된 비디오 플레이어를 재생 및 일시정지하는 경우
- 원격 서버에 연결해서 메시지를 수신해야 할 경우

> React의 `외부`로 나가서 외부 시스템에 연결할 수 있는 탈출구에 대해 알아보자.

## 이 챕터에서 다룰 내용

- 리렌더링하지 않고 정보를 “기억”하는 방법
- React가 관리하는 DOM 엘리먼트에 접근하는 방법
- 컴포넌트를 외부 시스템과 동기화하는 방법
- 컴포넌트에서 불필요한 Effect를 제거하는 방법
- effect의 생명주기가 컴포넌트와 어떻게 다른지
- 일부 값이 Effect를 다시 촉발하는 것을 방지하는 방법
- Effect 재실행 빈도를 줄이는 방법
- 컴포넌트 간 로직을 공유하는 방법

</br>

# ref로 값 참조하기

- 컴포넌트가 특정 정보를 `기억` 하도록 하고 싶지만 해당 정고가 `새 렌더링을 촉발하지 않도록` 하려는 경우 ref를 사용할 수 있다.

## 컴포넌트에 ref 추가하기

1. useRef 훅을 가져온다.

```jsx
import { useRef } from "react";
```

2. useRef 혹을 호출하고 참조할 초기밧을 인자로 전달한다.

```jsx
const ref = useRef(0);
```

3. useRef는 다음과 같은 객체를 반환한다.

```json
{
  "current": 0 // The value you passed to useRef
}
```

- ref.current 속성을 통해 해당 ref의 현재 값에 엑세스할 수 있다.
- 이 값은 읽기와 쓰기가 모두 가능하다.

```jsx
import { useRef } from "react";

export default function Counter() {
  let ref = useRef(0);

  function handleClick() {
    ref.current = ref.current + 1;
    alert("You clicked " + ref.current + " times!");
  }

  return <button onClick={handleClick}>Click me!</button>;
}
```

> `ref`는 React가 추적하지 않는 컴포넌트의 `비밀 주머니`와 같다.

- ref는 숫자 뿐만이 아닌 state와 마찬가지로 문자열, 객체, 함수 등 무엇이든 가리킬 수 있다.
- ref는 current 속성을 읽고 수정할 수 있는 일반 JavaScript 객체다.
- **ref는 state와 마찬가지로 값을 유지하면서 state와는 다르게 컴포넌트가 리렌더링되지 않는다.**

## state와 ref 함께 사용하기 (스톱워치)

```jsx
import { useState, useRef } from "react";

export default function Stopwatch() {
  // 컴포넌트가 새로운 값으로 렌더링 되어야하는 시간은 state로 관리한다.
  const [startTime, setStartTime] = useState(null);
  const [now, setNow] = useState(null);

  // 컴포넌트 렌더링과는 상관 없지만 기억해야하는 interval ID는 ref로 관리한다.
  const intervalRef = useRef(null);

  function handleStart() {
    setStartTime(Date.now());
    setNow(Date.now());

    // setInterval이 호출한 interval ID를 clearInterval()에 제공
    clearInterval(intervalRef.current);
    intervalRef.current = setInterval(() => {
      setNow(Date.now());
    }, 10);
  }

  function handleStop() {
    // setInterval이 호출한 interval ID를 clearInterval()에 제공
    clearInterval(intervalRef.current);
  }

  let secondsPassed = 0;
  if (startTime != null && now != null) {
    secondsPassed = (now - startTime) / 1000;
  }

  return (
    <>
      <h1>Time passed: {secondsPassed.toFixed(3)}</h1>
      <button onClick={handleStart}>Start</button>
      <button onClick={handleStop}>Stop</button>
    </>
  );
}
```

- 렌더링에 정보가 사용되는 경우 해당 정보를 state로 유지한다.
- 이벤트 핸들러만 정보를 필요로 하고 변경해도 다시 렌더링할 필요가 없는 경우 ref를 사용한다.

## ref와 state의 차이점

| refs                                                                       | state                                                                                         |
| -------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------- |
| useRef(initialValue)는 { current: initialValue }을 반환                    | useState(initialValue)는 state 변수의 현재값과 state 설정자함수([value, setValue])를 반환     |
| 변경 시 리렌더링을 촉발하지 않음                                           | 변경 시 리렌더링을 촉발함                                                                     |
| Mutable— 렌더링 프로세스 외부에서 current 값을 수정하고 업데이트할 수 있음 | “Immutable”— state setting 함수를 사용하여 state 변수를 수정해 리렌더링을 대기열에 추가해야함 |
| 렌더링 중에는 current 값을 읽거나 쓰지 않아야 함                           | 언제든지 state를 읽을 수 있음. 각 렌더링에는 변경되지 않는 자체 state snapshot이 있음         |

## ref는 설정자가 없는 일반 state 변수라고 생각하면 된다.

```jsx
// Inside of React
function useRef(initialValue) {
  const [ref, unused] = useState({ current: initialValue });
  return ref;
}
```

## ref를 사용해야 하는 경우

ref는 컴포넌트가 React로부터 `외부로 나가서` 외부 API, 즉 컴포넌트의 형상에 영향을 주지 않는 브라우저 API 등과 통신해야 할 때 사용된다.

- timeout ID 저장
- 다음 페이지에서 다룰 DOM elements 저장 및 조작
- JSX를 계산하는 데 필요하지 않은 다른 객체 저장

> 컴포넌트에 일부 값을 저장해야 하지만 렌더링 로직에는 영향을 미치지 않는 경우에 사용한다.

## ref 모범 사례

- ref를 탈출구(외부 시스템, API 작업)로 취급하자.
- 애플리케이션 로직과 데이터 흐름에는 사용을 조심하자.
- 렌더링 중에는 ref.current를 읽거나 쓰지 말자.(첫 번째 렌더링에만 사용)
- ❓렌더링 중이라는 것은 첫 마운트 제외하고 리랜더링의 경우를 말하는 건가?

> state는 모든 렌더링에서 스냅샷처럼 작동하며 동기적으로 업데이트 되지 않지만 ref는 값을 변경하는 즉시 변경된다.

</br>

# ref로 DOM 조작하기

- React는 렌더링 출력과 일치하도록 DOM을 자동으로 업데이트 해준다.
- 하지만 노드에 초점을 맞추거나 스크롤하거나 크기와 위치를 측정하기 위해 React가 관리하는 DOM요소에 접근해야 할 수도 있다.
- DOM노드에 대한 ref를 만들어서 접근한다.

## 노드에 대한 ref 가져오기

1. useRef 훅을 불러온다.

```jsx
import { useRef } from "react";
```

2. 컴포넌트 내부에서 ref를 선언한다.

```jsx
const myRef = useRef(null);
```

3. **DOM 노드를 가져올 JSX 태그에 ref 속성으로 참조를 전달한다.**

```jsx
<div ref={myRef}>
```

- useRef 훅은 current라고 하는 프로퍼티가 포함된 객체를 반환한다.
- 처음 myRef.current는 null을 가진다.
- React가 `<div>`에 대한 DOM 노드를 생성하면, useRef.current에 노드가 들어간다.
- 노드를 가진 useRef.current는 빌트인 브라우서 API 사용이 가능하다.

```jsx
// 모든 브라우저 API를 사용할 수 있다. 예를 들어:
myRef.current.scrollIntoView();
```

## 텍스트 input에 초점 맞추기

```jsx
import { useRef } from "react";

export default function Form() {
  const inputRef = useRef(null);

  function handleClick() {
    inputRef.current.focus();
  }

  return (
    <>
      // 노드에 ref 전달
      <input ref={inputRef} />
      <button onClick={handleClick}>Focus the input</button>
    </>
  );
}
```

- `<input ref={inputRef} />` input의 DOM 노드를 `inputRef.current`에 넣는다.
- handleClick 함수에서 inputRef.current로부터 `input DOM 노드를 읽어`와서 inputRef.current.focus()로 `focus()를 호출`합니다.

## ref 콜백을 사용하여 refs 목록을 관리하는 방법

필요한 DOM 노드를 ref로 만들어서 사용해봤다.  
하지만, 한 목록의 모든 요소를 사용한다면 어떻게 될까?  
**얼마나 많은 ref가 필요한지 알 수 없는 경우의 방법을 알아보자**

- ref 속성에 함수를 전달해준다. 이를 `ref 콜백`이라고 한다.
- React는 ref를 설정할 떄가 되면 DOM 노드로, 지울 때가 되면 null로 ref 콜백을 호출한다.
- 이를 통해 자신만의 배열(인덱스)이나 Map(ID)로 모든 ref에 접근할 수 있다.

```jsx
import { useRef } from "react";

export default function CatFriends() {
  const itemsRef = useRef(null);

  function scrollToId(itemId) {
    const map = getMap(); // map으로 저장된 itemsRef 가져오기
    const node = map.get(itemId); // map안에서 선택된 id로 node 가져오기
    node.scrollIntoView({
      behavior: "smooth",
      block: "nearest",
      inline: "center",
    });
  }

  function getMap() {
    if (!itemsRef.current) {
      // Initialize the Map on first usage.
      itemsRef.current = new Map();
    }
    return itemsRef.current;
  }

  return (
    <>
      <nav>
        <button onClick={() => scrollToId(0)}>Tom</button>
        <button onClick={() => scrollToId(5)}>Maru</button>
        <button onClick={() => scrollToId(9)}>Jellylorum</button>
      </nav>
      <div>
        <ul>
          {catList.map((cat) => (
            <li
              key={cat.id}
              ref={(node) => {
                const map = getMap();
                if (node) {
                  map.set(cat.id, node);
                } else {
                  map.delete(cat.id);
                }
              }}
            >
              <img src={cat.imageUrl} alt={"Cat #" + cat.id} />
            </li>
          ))}
        </ul>
      </div>
    </>
  );
}

const catList = [];
for (let i = 0; i < 10; i++) {
  catList.push({
    id: i,
    imageUrl: "https://placekitten.com/250/200?image=" + i,
  });
}
```

- 위 예제에서 itemsRef는 하나만의 DOM 노드를 보유하지 않는다.
- DOM 노드들이 모여있는 Map을 보유한다.

```jsx
<li
  key={cat.id}
  ref={node => {
    const map = getMap();
    if (node) {
      // Add to the Map
      map.set(cat.id, node);
    } else {
      // Remove from the Map
      map.delete(cat.id);
    }
  }}
>
```

- catList에서 노드를 만들때 ref map도 업데이트 된다.

## 다른 컴포넌트의 DOM 노드에 접근하기

- 위 예제들에서는 빌트인 컴포넌트 `<input>`, `li` 등에 ref를 주었다.
- 하지만 만들어진 컴포넌트(함수 컴포넌트)에 ref를 넣으면 기본적으로 null이 반환된다.

```jsx
import { useRef } from "react";

// 만들어진 input을 반환하는 함수 컴포넌트
function MyInput(props) {
  return <input {...props} />;
}

export default function MyForm() {
  const inputRef = useRef(null);

  function handleClick() {
    inputRef.current.focus();
  }

  return (
    <>
      <MyInput ref={inputRef} />
      <button onClick={handleClick}>Focus the input</button>
    </>
  );
}
```

```
Warning: Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?
// 경고: 함수 컴포넌트에는 refs를 지정할 수 없습니다. 이 ref에 접근하려는 시도는 실패합니다. React.forwardRef()를 사용하려고 하셨나요?
```

> 기본적으로 React는 한 컴포넌트가 다른 컴포넌트의 DOM 노드에 접근하는 것을 차단하기 때문이다.

- 해결방법으로는 DOM 노드를 다른 컴포넌트가 사용할 수 있도록 설정해야한다.
- 이는 상위 컴포넌트로부터 ref를 전달 받을 수 있도록 하는 것이다.

```jsx
const MyInput = forwardRef((props, ref) => {
  return <input {...props} ref={ref} />;
});
```

- MyInput 컴포넌트를 `forwardRef`를 사용하여 선언하면, props 다음의 두 번째 `ref 인수`에 상위 컴포넌트의 `inputRef`를 받도록 설정한다.
- MyInput은 수신한 ref를 내부의 `<input>`으로 전달한다.

```jsx
import { forwardRef, useRef } from "react";

const MyInput = forwardRef((props, ref) => {
  return <input {...props} ref={ref} />;
});

export default function Form() {
  const inputRef = useRef(null);

  function handleClick() {
    inputRef.current.focus();
  }

  return (
    <>
      <MyInput ref={inputRef} />
      <button onClick={handleClick}>Focus the input</button>
    </>
  );
}
```

> 위와 같은 방식은 버튼, 입력 등과 같은 저수준 컴포넌트에서만 사용하는 것이 좋다.

## DOM 노트 노출을 제한하기

위 예제에서 MyInput은 DOM input 엘리먼트를 노출하고 있다.  
만약 focus()만을 위해서 노출을 하도록 만들고 싶다면 `useImperativeHandle`를 사용할 수 있다.

```jsx
import { forwardRef, useRef, useImperativeHandle } from "react";

const MyInput = forwardRef((props, ref) => {
  const realInputRef = useRef(null);
  useImperativeHandle(ref, () => ({
    // Only expose focus and nothing else
    focus() {
      realInputRef.current.focus();
    },
  }));
  return <input {...props} ref={realInputRef} />;
});

export default function Form() {
  const inputRef = useRef(null);

  function handleClick() {
    inputRef.current.focus();
  }

  return (
    <>
      <MyInput ref={inputRef} />
      <button onClick={handleClick}>Focus the input</button>
    </>
  );
}
```

## React가 ref를 첨부할 때

React에서 모든 업데이트는 두 단계로 나뉜다.

- 렌더링 : React는 컴포넌트를 호출하여 화면에 무엇이 표시되어야 하는지 파악한다.
  - 렌더링 중에는 DOM 노드가 아직 생성되지 않았으므로 ref.current는 null이다.
- 커밋 : React는 DOM에 변경 사항을 적용한다.
  - 커밋 단계에서 ref.current를 설정한다.
  - DOM이 업데이트된 직후 해당 DOM 노드를 다시 설정한다.

## state를 동기식으로 업데이트하기

아래 예제에서 todo 목록이 추가되면 추가된 노드로 스크롤이 이동되게 하고자 한다.

```jsx
import { useState, useRef } from "react";

export default function TodoList() {
  const listRef = useRef(null);
  const [text, setText] = useState("");
  const [todos, setTodos] = useState(initialTodos);

  function handleAdd() {
    const newTodo = { id: nextId++, text: text };
    setText("");
    setTodos([...todos, newTodo]);
    listRef.current.lastChild.scrollIntoView({
      behavior: "smooth",
      block: "nearest",
    });
  }

  return (
    <>
      <button onClick={handleAdd}>Add</button>
      <input value={text} onChange={(e) => setText(e.target.value)} />
      <ul ref={listRef}>
        {todos.map((todo) => (
          <li key={todo.id}>{todo.text}</li>
        ))}
      </ul>
    </>
  );
}

let nextId = 0;
let initialTodos = [];
for (let i = 0; i < 20; i++) {
  initialTodos.push({
    id: nextId++,
    text: "Todo #" + (i + 1),
  });
}
```

- 결과는 추가된 노드위치가 아닌 그 이전 상태의 마지막 노드로 이동된다.
- state는 DOM을 즉시 업데이트 하지 않기 때문이다.

```jsx
setTodos([...todos, newTodo]);
listRef.current.lastChild.scrollIntoView();
```

- setTodos는 업데이트 된 후 재렌더링으로 노드를 추가한다.
- scrollIntoView()는 업데이트 단계에서 진행이 되버린다.
- **`flushSync`로 state 업데이트를 동기적으로 만들 수 있다.**

```jsx
import { useState, useRef } from "react";
import { flushSync } from "react-dom";

export default function TodoList() {
  const listRef = useRef(null);
  const [text, setText] = useState("");
  const [todos, setTodos] = useState(initialTodos);

  function handleAdd() {
    const newTodo = { id: nextId++, text: text };
    flushSync(() => {
      setText("");
      setTodos([...todos, newTodo]);
    });
    listRef.current.lastChild.scrollIntoView({
      behavior: "smooth",
      block: "nearest",
    });
  }

  return (
    <>
      <button onClick={handleAdd}>Add</button>
      <input value={text} onChange={(e) => setText(e.target.value)} />
      <ul ref={listRef}>
        {todos.map((todo) => (
          <li key={todo.id}>{todo.text}</li>
        ))}
      </ul>
    </>
  );
}

let nextId = 0;
let initialTodos = [];
for (let i = 0; i < 20; i++) {
  initialTodos.push({
    id: nextId++,
    text: "Todo #" + (i + 1),
  });
}
```

## ref를 이용한 DOM 조작 모범 사례

- React가 관리하는 DOM 노드를 변경하면 안된다.
- React가 업데이트할 이유가 없는 DOM의 일부는 안전하게 수정할 수 있다.
