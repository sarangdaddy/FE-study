# 리액트 쿼리 - 캐싱

## 리액트 쿼리에서의 캐싱 라이프 사이클

- 쿼리 인스턴스 `useQuery({queryKey : ['todos'], queryFn : fetchTodos})`가 마운트 된다.
- `queryKey : ['todos']`가 존재하지 않으면 fetch하여 데이터를 받아온다.
- 받아온 데이터는 `['todos']`에 캐싱된다.
- 이 데이터는 fresh 상태에서 `staleTime(기본값 0)` 이후 stale 상태로 변경된다.
- 쿼리 인스턴스가 언마운트된다.
- 쿼리 인스턴스가 다시 마운트 된다면, `['todos']`키가 존재하기에 데이터 패치 없이 바로 사용한다.
- 데이터 상태가 stale라면 오래된 데이터로 간주하고 백그라운드에서 데이터 변경사항을 검토한다.
- 변경된 데이터가 존재한다면 데이터를 업데이트 한다. (fetch가 반드시 일어나지는 않는다.)
- 쿼리 인스턴스가 `cacheTime (기본값 5분)` 동안 마운트 되지 않으면 `['todos']`키값은 삭제된다.
- 캐싱된 데이터는 가비지 콜렉터로 제거된다.

## staleTime vs cacheTime

### staleTime

- staleTime은 쿼리가 마지막으로 성공적으로 실행된 이후 데이터가 "신선함(fresh)" 상태로 간주되는 시간을 정의한다.
- 이 시간 동안 데이터는 최신 상태로 간주되며, 리액트 쿼리는 쿼리를 자동으로 재실행하지 않는다. 
- 즉, staleTime 동안에는 쿼리 결과에 대한 자동 업데이트가 발생하지 않는다.

### cacheTime (Garbage Collection Time)
- cacheTime은 쿼리 인스턴스가 언마운트된 후에 해당 쿼리 데이터가 캐시에서 유지되는 시간을 정의한다.
- 이 시간이 지나면, 데이터는 캐시에서 제거된다.
- 즉, cacheTime은 캐시에서 데이터가 가비지 컬렉션될 때까지의 시간을 결정한다.

> staleTime은 데이터가 신선함 상태로 유지되는 시간을 결정한다.  
> 반면, cacheTime은 데이터가 언마운트된 후 캐시에서 유지되는 시간을 결정한다.  
> staleTime은 자동 데이터 재요청의 필요성을 관리하는 반면, cacheTime은 메모리 사용 및 캐시 관리에 집중한다.

