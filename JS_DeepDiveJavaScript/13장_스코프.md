# 13장 스코프

# 13.1 스코프란?

- 스코프란 식별자가 `유효한 범위`를 말한다.
- 여기서 유효한 범위란 다른 코드가 식별자 자신을 참조할 수 있는지를 말하며
- 이는 식별자가 선언된 위치에 의해 결정된다.
- 스코프란 자바스크립트 엔진이 **식별자를 검색하는 규칙**이라고도 할 수 있다.

```jsx
var x = "global";

function foo() {
  var x = "local";
  console.log(x);
}

foo();
console.log(x);

// 'local'
// 'global'
```

위 예제에서 코드의 가장 바깥 영역에 선언된 x 변수는 어디서든 참조할 수 있다.  
하지만 foo 함수 내부에서 선언된 x 변수는 foo 함수 내부에서만 참조할 수 있고,  
foo 함수 외부에서는 참조할 수 없다.  
이때 두 개의 x 변수는 식별자 이름이 동일하지만 자신이 유효한 범위, 즉 스코프가 다른 별개의 변수다.

**식별자는 유일해야 하는데 변수 이름이 중복되어도 되는가?**

🤔 파일 이름을 예로 들어보자.  
파일 이름은 하나의 파일을 구별하여 식별할 수 있는 식별자다.  
하지만 컴퓨터를 사용할 때 하나의 파일 이름만 사용하지는 않는다.  
-> 이유는 폴더(디렉토리)라는 개념이 있기 때문이다.

> 위와 마찬가지로 프로그래밍 언어에서는 `스코프(유효 범위) 를 통해 식별자인 변수 이름의 충돌을 방지`하여 같은 이름의 변수를 사용할 수 있게 한다.  
> 스코프 내에서 식별자는 유일해야 하지만 다른 스코프에는 같은 이름의 식별자를 사용할 수 있다.  
> 즉, 스코프는 `네임스페이스` 다.

☝️ `var`키워드로 선언된 변수는 같은 스코프 내에서 중복 선언이 허용된다.  
이는 의도치 않게 변수값이 재할당되어 변경되는 `부작용`을 발생시킨다.  
하지만 `let` 이나 `const` 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용하지 않는다.

# 13.2 스코프의 종류

스코프는 `전역`과 `지역`으로 구분할 수 있다.

| 구분 | 설명                  | 스코프      | 변수      |
| ---- | --------------------- | ----------- | --------- |
| 전역 | 코드의 가장 바깥 영역 | 전역 스코프 | 전역 변수 |
| 지역 | 함수 몸체 내부        | 지역 스코프 | 지역 변수 |

```jsx
var x = "global x";
var y = "global y";

function outer() {
  var z = "outer's local z";

  console.log(x); // 1️⃣ global x
  console.log(y); // 2️⃣ global y
  console.log(z); // 3️⃣ outer's local z

  function inner() {
    var x = "inner's local x";

    console.log(x); // 4️⃣ inner's local x
    console.log(y); // 5️⃣ global y
    console.log(z); // 6️⃣ outer's local z
  } // 지역 스코프

  inner();
} // 지역 스코프

outer();

console.log(x); // 7️⃣ global x
console.log(z); // 8️⃣ ReferenceError: z is not defined
// 전역 스코프
```

### 전역과 전역 스코프

- **전역 변수는 어디서든지 참조할 수 있다.**
- 위 예제에서 코드 가장 바깥 영역인 전역에서 선언된 x 변수와 y 변수는 전역 변수다.
- 전역 변수는 어디서든 참조할 수 있으므로 함수 내부에서도 참조할 수 있다.

### 지역과 지역 스코프

- **지역 변수는 자신의 지역 스코프와 하위 지역 스코프에서 유효하다.**
- 위 예제에서 outer 함수 내부에서 선언된 z는 지역 변수다.
  - 지역 변수 z는 자신의 지역 스코프인 outer 함수 내부와 하위 지역 스코프인 inner 함수 내부에서만 참조할 수 있다.
- inner 함수 내부에서 선언된 x 변수도 지역 변수다.
  - 지역 변수 x는 자신의 지역 스코프인 함수 inner 내부에서만 참조할 수 있다.

# 13.3 스코프 체인

함수 몸체 내부에서 함수가 정의된 것을 `함수의 중첩`이라 한다.  
그리고 함수 몸체 내부에서 정의한 함수를 `중첩 함수`,  
중첩 함수를 포함하는 함수를 `외부 함수`라고 한다.

- 함수는 중첨될 수 있으므로 함수의 지역 스코프도 중첩될 수 있다.
  이는 **스코프가 함수의 중첩에 의해 `계층적 구조`를 갖는다**는 것을 의미한다.
- 모든 스코프는 하나의 계층적 구조로 연결되며, 모든 지역 스코프의 최상의 스코프는 전역 스코프다.

이처럼 **스코프가 계측적으로 연결된 것을 `스코프 체인(scope chain)`이라 한다.**

> **변수를 참조할 때 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여
> 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다.**

## 스코프 체인에 의한 변수 검색

```bash
위 예제의 4️⃣, 5️⃣, 6️⃣ 을 살펴본다.

4️⃣
- x 변수를 참조하는 코드의 스코프인 inner 함수의 지역 스코프에서 x 변수가 선언되었는지 검색한다.
- inner 함수 내에는 선언된 x 변수가 존재한다.
- 따라서 검색된 변수를 참조하고 검색을 종료한다.

5️⃣
- y 변수를 참조하는 코드의 스코프인 inner 함수의 지역 스코프에서 y 변수가 선언되었는지 검색한다.
- inner 함수 내에는 y 변수의 선언이 존재하지 않으므로 상위 스코프인 outer 함수의 지역 스코프로 이동한다.
- outer 함수 내에도 y 변수의 선언이 존재하지 않으므로 또 다시 상위 스코프인 전역 스코프로 이동한다.
- 전역 스코프에는 y 변수의 선언이 존재한다.
- 따라서 검색된 변수를 참조하고 검색을 종료한다.

6️⃣
- z 변수를 참조하는 코드의 스코프인 inner 함수의 지역 스코프에서 z 변수가 선언되었는지 검색한다.
- inner 함수 내에는 z 변수의 선언이 존재하지 않으므로 상위 스코프인 outer 함수의 지역 스코프로 이동한다.
- outer 함수 내에는 z 변수의 선언이 존재한다.
- 따라서 검색된 변수를 참조하고 검색을 종료한다.
```

> **상위 스코프에서 유효한 변수는 하위 스코프에서 자유롭게 참조할 수 있지만
> 하위 스코프에서 유효한 변수를 상위 스코프에서 참조할 수 없다**

# 13.4 함수 레벨 스코프

지역은 함수 몸체 내부를 말하고 지역은 지역 스코프를 만든다고 했다.  
이는 **코드 블록이 아닌 함수에 의해서만 지역 스코프가 생성된다는 의미다.**

☝️ **var 키워드로 선언된 변수는 오로지 함수의 코드 블록(함수 몸체)만을 지역 스코프로 인정**한다.  
이러한 특성을 `함수 레벨 스코프(function level scope)`라 한다.

```jsx
var i = 10;

// for 문에서 선언한 i는 전역 변수다. 이미 선언된 전역 변수 i가 있으므로 중복 선언된다.
for (var i = 0; i < 5; i++) {
  console.log(i); // 0 1 2 3 4
}

// 의도치 않게 변수의 값이 변경되었다.
console.log(i); // 5
```

`블록 레벨 스코프`를 지원하는 프로그래밍 언어에서는 for 문에서 반복을 위해 선언된 i 변수가 for 문의 코드 블록 내에서만 유효한 지역 변수다.  
하지만 var 키워드로 선언된 변수는 블록 레벨 스코프를 인정하지 않기 때문에 i 변수는 전역 변수가 된다.

☝️ `var` 키워드로 선언된 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정하지만
ES6에서 도입된 `let`, `const` 키워드는 블록 레벨 스코프를 지원한다.

## ☘️ 중간 퀴즈 ☘️

```jsx
// 아래의 결과는??
var n = 1;
function test() {
  console.log(n);
  var n = 2;
  console.log(n);
}
test();
```

<details>
<summary>결과</summary>
<div markdown="1">

```js
undefined;
2;
```

</div>
</details>

답이 틀렸다면 [여기 글](https://www.daleseo.com/js-var-issues/)을 참고하고 돌아오자.

## 🧐 var 키워드의 단점

- `블록 레벨 스코프(block level scope)`를 인정하지 않고 `함수 레벨 스코프(function level scope)`를 가진다.

```jsx
var x = 1;

if (true) {
  // var 키워드로 선언된 변수는 함수의 코드 블록(함수 몸체)만을 지역 스코프로 인정한다.
  // 아래는 의도치 않게 변수 값이 변경되는 부작용을 발생시킨다.
  var x = 10;
}

console.log(x); // 10
```

```jsx
// var 키워드로 선언된 변수의 스코프를 제한하기 위해 즉시 실행 함수를 사용하기도 한다.
// var 키워드는 함수 레벨 스코프를 가지기 때문에 즉시 실행 함수로 묶으면 변수의 스코프를 제한할 수 있다.
var x = 1;

(function () {
  if (true) {
    var x = 10;
  }
})();

console.log(x); // 1
```

- 같은 스코프 내에서 중복 선언이 허용된다.

```jsx
function foo() {
  var x = 1;
  // var 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허락한다.
  // 아래 변수 선언문은 자바스크립트 엔진에 의해 var 키워드가 없는 것처럼 동작한다.
  var x = 2;
  console.log(x); // 2
}
foo();
```

- [호이스팅(hoisting)](https://velog.io/@sarang_daddy/JS-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85hoisting)

```jsx
console.log(x); // undefined
var x;
```

```jsx
console.log(x); // 1
x = 2;
console.log(x); // 2
var x = 1;
```

> var키워드를 사용하면 코드가 전반적으로 어떻게 작동될지 직관적으로 예측하기 어렵다.

# 13.5 렉시컬 스코프

프로그래밍 언어가 일반적으로 함수의 상위 스코프를 결정하는 방식은 아래 두가지가 있다.

1. **함수를 어디서 호출**했는지에 따라 함수의 상위 스코프를 결정한다.
2. **함수를 어디서 정의**했는지에 따라 함수의 상위 스코프를 결정한다.

**첫 번째** 방식을 `동적 스코프(dynamic scope)`라 한다.  
함수를 정의하는 시점에는 함수가 어디서 호출될지 알 수 없다.  
따라서 함수가 호출되는 시점에 동적으로 상위 스코프를 결정해야 하기 때문에 동적 스코프라고 부른다.

**두 번째** 방식을 `렉시컬 스코프(lexical scope)`또는 `정적 스코프(static scope)`라 한다.  
동적 스코프 방식처럼 상위 스코프가 동적으로 변하지 않고 함수 정의가 평가되는 시점에  
상위 스코프가 정적으로 결정되기 때문에 정적 스코프라고 부른다.

**자바스크립트를 비롯한 대부분의 프로그래밍 언어는 렉시컬 스코프를 따른다.**

> **즉, 자바스크립트에서 함수의 상위 스코프는 언제나 자신이 정의된 스코프다.  
> 함수의 상위 스코프는 함수 정의가 실행될 때 정적으로 결정된다.  
> 함수 정의(함수 선언문 또는 함수 표현식)가 실행되어 생성된 함수 객체는 이렇게 결정된 상위 스코프를 기억한다.  
> 함수가 호출될 때마다 함수의 상위 스코프를 참조할 필요가 있기 때문이다.**

```jsx
var x = 1;

function foo() {
  var x = 10;
  bar();
}

function bar() {
  console.log(x);
}

foo(); // 1
bar(); // 1
```

- 위 예제의 bar 함수는 전역에서 정의된 함수다.
- 함수 선언문으로 정의된 bar 함수는 전역 코드가 실행되기 전에 먼저 평가되어 함수 객체를 생성한다.
- **이때 생성된 bar 함수 객체는 자신이 정의된 스코프, 즉 전역 스코프를 기억한다.**
- 그리고 bar 함수가 호출되면 호출된 것이 어디인지 관계없이 언제나 자신이 기억하고 있는 전역 스코프를 상위 스코프로 사용한다.
- 따라서 위 예제를 실행하면 전역 변수 x의 값 1을 두 번 출력한다.

## ☘️ 중간 퀴즈 ☘️

아래의 결과는???

```jsx
let x = 1;

const foo = () => {
  let x = 10;
  bar();
};

const bar = () => {
  console.log(x);
};

foo();
bar();
```

<details>
<summary>결과</summary>
<div markdown='2'>

```js
1;
1;
// var와는 상관없는 렉시컬 스코프에 관한 문제다.
// let, const를 사용해도 bar()가 정의된 시점에 상위 스코프는 정해진다.
```

</div>
</details>
